[
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "csr_matrix",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "connected_components",
        "importPath": "scipy.sparse.csgraph",
        "description": "scipy.sparse.csgraph",
        "isExtraImport": true,
        "detail": "scipy.sparse.csgraph",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "shuffle",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "gdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gdb",
        "description": "gdb",
        "detail": "gdb",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "find_library",
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "isExtraImport": true,
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "svm",
        "description": "svm",
        "isExtraImport": true,
        "detail": "svm",
        "documentation": {}
    },
    {
        "label": "__all__",
        "importPath": "svm",
        "description": "svm",
        "isExtraImport": true,
        "detail": "svm",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "PyNomad",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyNomad",
        "description": "PyNomad",
        "detail": "PyNomad",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "NONE",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "NONE",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "process",
        "importPath": "buildtools",
        "description": "buildtools",
        "isExtraImport": true,
        "detail": "buildtools",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "is_planar",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def is_planar(edge_list):\n\t#return planarity.is_planar(edge_list)\n\treturn False\ndef num_connected_components(adj_matrix):\n\tgraph = csr_matrix(adj_matrix)\n\tnum_components = connected_components(csgraph=graph, directed=False, return_labels=False)\n\treturn num_components\ndef is_cyclic_util(adj_list, node_id, visited, parent_id):\n\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "num_connected_components",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def num_connected_components(adj_matrix):\n\tgraph = csr_matrix(adj_matrix)\n\tnum_components = connected_components(csgraph=graph, directed=False, return_labels=False)\n\treturn num_components\ndef is_cyclic_util(adj_list, node_id, visited, parent_id):\n\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:\n\t\tif not visited[neighbor_id]:\n\t\t\tif is_cyclic_util(adj_list, neighbor_id, visited, node_id):\n\t\t\t\treturn True",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "is_cyclic_util",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def is_cyclic_util(adj_list, node_id, visited, parent_id):\n\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:\n\t\tif not visited[neighbor_id]:\n\t\t\tif is_cyclic_util(adj_list, neighbor_id, visited, node_id):\n\t\t\t\treturn True\n\t\telif neighbor_id != parent_id:\n\t\t\t\treturn True\n\treturn False\ndef is_cyclic(adj_list, num_nodes):",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "is_cyclic",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def is_cyclic(adj_list, num_nodes):\n\tvisited = [False for node_id in range(num_nodes)]\n\tfor node_id in range(num_nodes):\n\t\tif not visited[node_id]:\n\t\t\tif is_cyclic_util(adj_list, node_id, visited, -1):\n\t\t\t\treturn True\n\treturn False\ndef as_2d_hist(min_num_nodes, max_num_nodes, min_num_edges, max_num_edges, nums_nodes, nums_edges):\n    hist = {num_nodes : {num_edges : 0 for num_edges in range(min_num_edges, max_num_edges + 1)} for num_nodes in range(min_num_nodes, max_num_nodes + 1)}\n    num_graphs = len(nums_nodes)",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "as_2d_hist",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def as_2d_hist(min_num_nodes, max_num_nodes, min_num_edges, max_num_edges, nums_nodes, nums_edges):\n    hist = {num_nodes : {num_edges : 0 for num_edges in range(min_num_edges, max_num_edges + 1)} for num_nodes in range(min_num_nodes, max_num_nodes + 1)}\n    num_graphs = len(nums_nodes)\n    for i in range(num_graphs):\n        hist[nums_nodes[i]][nums_edges[i]] = hist[nums_nodes[i]][nums_edges[i]] + 1\n    return hist\ndef parse_graph(dir, gxl_file):\n    num_nodes = 0\n    graph = ET.parse(os.path.join(dir, gxl_file)).getroot()\n    str_to_id = {}",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "parse_graph",
        "kind": 2,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "def parse_graph(dir, gxl_file):\n    num_nodes = 0\n    graph = ET.parse(os.path.join(dir, gxl_file)).getroot()\n    str_to_id = {}\n    for node in graph.findall(\"graph/node\"):\n        str_to_id.update({node.attrib[\"id\"] : num_nodes})\t\n        num_nodes = num_nodes + 1\n    edge_list = []\n    adj_list = {node_id : [] for node_id in range(num_nodes)}\n    adj_matrix = [[0 for col in range(num_nodes)] for row in range(num_nodes)]",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tgraph",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tgraph = csr_matrix(adj_matrix)\n\tnum_components = connected_components(csgraph=graph, directed=False, return_labels=False)\n\treturn num_components\ndef is_cyclic_util(adj_list, node_id, visited, parent_id):\n\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:\n\t\tif not visited[neighbor_id]:\n\t\t\tif is_cyclic_util(adj_list, neighbor_id, visited, node_id):\n\t\t\t\treturn True\n\t\telif neighbor_id != parent_id:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tnum_components",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tnum_components = connected_components(csgraph=graph, directed=False, return_labels=False)\n\treturn num_components\ndef is_cyclic_util(adj_list, node_id, visited, parent_id):\n\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:\n\t\tif not visited[neighbor_id]:\n\t\t\tif is_cyclic_util(adj_list, neighbor_id, visited, node_id):\n\t\t\t\treturn True\n\t\telif neighbor_id != parent_id:\n\t\t\t\treturn True",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tvisited[node_id]",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tvisited[node_id] = True\n\tfor neighbor_id in adj_list[node_id]:\n\t\tif not visited[neighbor_id]:\n\t\t\tif is_cyclic_util(adj_list, neighbor_id, visited, node_id):\n\t\t\t\treturn True\n\t\telif neighbor_id != parent_id:\n\t\t\t\treturn True\n\treturn False\ndef is_cyclic(adj_list, num_nodes):\n\tvisited = [False for node_id in range(num_nodes)]",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tvisited",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tvisited = [False for node_id in range(num_nodes)]\n\tfor node_id in range(num_nodes):\n\t\tif not visited[node_id]:\n\t\t\tif is_cyclic_util(adj_list, node_id, visited, -1):\n\t\t\t\treturn True\n\treturn False\ndef as_2d_hist(min_num_nodes, max_num_nodes, min_num_edges, max_num_edges, nums_nodes, nums_edges):\n    hist = {num_nodes : {num_edges : 0 for num_edges in range(min_num_edges, max_num_edges + 1)} for num_nodes in range(min_num_nodes, max_num_nodes + 1)}\n    num_graphs = len(nums_nodes)\n    for i in range(num_graphs):",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Computes dataset statistics.\")\nparser.add_argument(\"dataset\", help=\"path to existing dataset file\")\nparser.add_argument(\"dir\", help=\"path to directory containing GXL files\")\nparser.add_argument(\"--max_size\", help=\"maximal size\", type=int)\nparser.add_argument(\"--topology\", help=\"compute topology avgerage number components and ratio of acyclic and planar graphs\", action=\"store_true\")\nparser.add_argument(\"--distr\", help=\"file to save distibution of number of nodes and edges\")\nargs = parser.parse_args()\nif not os.path.isdir(args.dir):\n\traise Exception(\"Invalid argument \\\"\" + dir + \"\\\": not a directory. Usage: python analyze_dataset.py <dataset> <dir> [--max-size <arg>]\")\n# Parse the dataset file.",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "args = parser.parse_args()\nif not os.path.isdir(args.dir):\n\traise Exception(\"Invalid argument \\\"\" + dir + \"\\\": not a directory. Usage: python analyze_dataset.py <dataset> <dir> [--max-size <arg>]\")\n# Parse the dataset file.\ndataset = ET.parse(args.dataset).getroot()\ngraphs = [graph.attrib[\"file\"] for graph in dataset]\n# Analyze the dataset.\nnum_graphs = 0\ntotal_num_graphs = 0\nratio_acyclic = 0.0",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "dataset = ET.parse(args.dataset).getroot()\ngraphs = [graph.attrib[\"file\"] for graph in dataset]\n# Analyze the dataset.\nnum_graphs = 0\ntotal_num_graphs = 0\nratio_acyclic = 0.0\nratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "graphs",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "graphs = [graph.attrib[\"file\"] for graph in dataset]\n# Analyze the dataset.\nnum_graphs = 0\ntotal_num_graphs = 0\nratio_acyclic = 0.0\nratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "num_graphs",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "num_graphs = 0\ntotal_num_graphs = 0\nratio_acyclic = 0.0\nratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "total_num_graphs",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "total_num_graphs = 0\nratio_acyclic = 0.0\nratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "ratio_acyclic",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "ratio_acyclic = 0.0\nratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "ratio_planar",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "ratio_planar = 0.0\nnums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue\n\tnum_graphs = num_graphs + 1",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "nums_nodes",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "nums_nodes = np.array([], dtype=int)\nnums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue\n\tnum_graphs = num_graphs + 1\n\tnums_nodes = np.append(nums_nodes, [num_nodes])",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "nums_edges",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "nums_edges = np.array([], dtype=int)\nnums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue\n\tnum_graphs = num_graphs + 1\n\tnums_nodes = np.append(nums_nodes, [num_nodes])\n\tnums_edges = np.append(nums_edges, [num_edges])",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "nums_components",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "nums_components = np.array([], dtype=int)\nfor gxl_file in graphs:\n\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue\n\tnum_graphs = num_graphs + 1\n\tnums_nodes = np.append(nums_nodes, [num_nodes])\n\tnums_edges = np.append(nums_edges, [num_edges])\n\tif args.topology:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\ttotal_num_graphs",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\ttotal_num_graphs = total_num_graphs + 1\n\tedge_list, adj_list, adj_matrix, num_nodes, num_edges = parse_graph(args.dir, gxl_file)\n\tif args.max_size and num_nodes > args.max_size:\n\t\tcontinue\n\tnum_graphs = num_graphs + 1\n\tnums_nodes = np.append(nums_nodes, [num_nodes])\n\tnums_edges = np.append(nums_edges, [num_edges])\n\tif args.topology:\n\t    num_components = num_nodes\n\t    if num_edges > 0:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tnum_graphs",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tnum_graphs = num_graphs + 1\n\tnums_nodes = np.append(nums_nodes, [num_nodes])\n\tnums_edges = np.append(nums_edges, [num_edges])\n\tif args.topology:\n\t    num_components = num_nodes\n\t    if num_edges > 0:\n\t\t    num_components = num_connected_components(adj_matrix)\n\t    nums_components = np.append(nums_components, [components])\n\t    if num_edges == 0 or not is_cyclic(adj_list, num_nodes):\n\t\t    ratio_acyclic = ratio_acyclic + 1.0",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tnums_nodes",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tnums_nodes = np.append(nums_nodes, [num_nodes])\n\tnums_edges = np.append(nums_edges, [num_edges])\n\tif args.topology:\n\t    num_components = num_nodes\n\t    if num_edges > 0:\n\t\t    num_components = num_connected_components(adj_matrix)\n\t    nums_components = np.append(nums_components, [components])\n\t    if num_edges == 0 or not is_cyclic(adj_list, num_nodes):\n\t\t    ratio_acyclic = ratio_acyclic + 1.0\n\t    if num_edges == 0 or is_planar(edge_list):",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "\tnums_edges",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "\tnums_edges = np.append(nums_edges, [num_edges])\n\tif args.topology:\n\t    num_components = num_nodes\n\t    if num_edges > 0:\n\t\t    num_components = num_connected_components(adj_matrix)\n\t    nums_components = np.append(nums_components, [components])\n\t    if num_edges == 0 or not is_cyclic(adj_list, num_nodes):\n\t\t    ratio_acyclic = ratio_acyclic + 1.0\n\t    if num_edges == 0 or is_planar(edge_list):\n\t\t    ratio_planar = ratio_planar + 1.0",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "ratio_acyclic",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "ratio_acyclic = ratio_acyclic / float(num_graphs)\nratio_planar = ratio_planar / float(num_graphs)\nprint(\"graphs (total / not filtered): \" + str(total_num_graphs) + \" / \" + str(num_graphs))\nprint(\"nodes (min / max / mean / std / median): \" + str(np.min(nums_nodes)) + \" & \" + str(np.max(nums_nodes)) + \" & \" + str(np.mean(nums_nodes)) + \" & \" + str(np.std(nums_nodes, ddof=1)) + \" & \" + str(np.median(nums_nodes)))\nprint(\"edges (min / max / mean / std / median): \" + str(np.min(nums_edges)) + \" & \" + str(np.max(nums_edges)) + \" & \" + str(np.mean(nums_edges)) + \" & \" + str(np.std(nums_edges, ddof=1)) + \" & \" + str(np.median(nums_edges)))\nif args.topology:\n    print(\"components (min / max / mean / std / median): \" + str(np.min(nums_components)) + \" & \" + str(np.max(nums_components)) + \" & \" + str(np.mean(nums_components)) + \" & \" + str(np.std(nums_components, ddof=1)) + \" & \" + str(np.median(nums_components)))\n    print(\"ratio planar graphs: \" + str(ratio_planar))\n    print(\"ratio acylcic graphs: \" + str(ratio_acyclic))\nif args.distr:",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "ratio_planar",
        "kind": 5,
        "importPath": "data.collections.analyze_dataset",
        "description": "data.collections.analyze_dataset",
        "peekOfCode": "ratio_planar = ratio_planar / float(num_graphs)\nprint(\"graphs (total / not filtered): \" + str(total_num_graphs) + \" / \" + str(num_graphs))\nprint(\"nodes (min / max / mean / std / median): \" + str(np.min(nums_nodes)) + \" & \" + str(np.max(nums_nodes)) + \" & \" + str(np.mean(nums_nodes)) + \" & \" + str(np.std(nums_nodes, ddof=1)) + \" & \" + str(np.median(nums_nodes)))\nprint(\"edges (min / max / mean / std / median): \" + str(np.min(nums_edges)) + \" & \" + str(np.max(nums_edges)) + \" & \" + str(np.mean(nums_edges)) + \" & \" + str(np.std(nums_edges, ddof=1)) + \" & \" + str(np.median(nums_edges)))\nif args.topology:\n    print(\"components (min / max / mean / std / median): \" + str(np.min(nums_components)) + \" & \" + str(np.max(nums_components)) + \" & \" + str(np.mean(nums_components)) + \" & \" + str(np.std(nums_components, ddof=1)) + \" & \" + str(np.median(nums_components)))\n    print(\"ratio planar graphs: \" + str(ratio_planar))\n    print(\"ratio acylcic graphs: \" + str(ratio_acyclic))\nif args.distr:\n    hist = as_2d_hist(min_num_nodes, max_num_nodes, min_num_edges, max_num_edges, nums_nodes, nums_edges)",
        "detail": "data.collections.analyze_dataset",
        "documentation": {}
    },
    {
        "label": "graph_size",
        "kind": 2,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "def graph_size(dir, gxl_file):\n    num_nodes = 0\n    graph = ET.parse(os.path.join(dir, gxl_file)).getroot()\n    for node in graph.findall(\"graph/node\"):\n        num_nodes = num_nodes + 1\n    #print(\"graph \", gxl_file, \" has size \", num_nodes)\n    return num_nodes\n# Parse the command line arguments.\nparser = argparse.ArgumentParser(description=\"Creates collection of graphs with given number of nodes from directory containing GXL files.\")\nparser.add_argument(\"dataset\", help=\"path to existing dataset file\")",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Creates collection of graphs with given number of nodes from directory containing GXL files.\")\nparser.add_argument(\"dataset\", help=\"path to existing dataset file\")\nparser.add_argument(\"collection\", help=\"path to sample file to be generated by the script\")\nparser.add_argument(\"dir\", help=\"path to directory containing GXL files\")\nparser.add_argument(\"min_size\", help=\"minimal number of nodes\", type=int)\nparser.add_argument(\"max_size\", help=\"maximal number of nodes\", type=int)\nargs = parser.parse_args()\nif args.dataset == args.collection:\n    raise Exception(\"dataset file equals collection file\")\nif not os.path.isdir(args.dir):",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "args = parser.parse_args()\nif args.dataset == args.collection:\n    raise Exception(\"dataset file equals collection file\")\nif not os.path.isdir(args.dir):\n        raise Exception(\"Invalid argument \\\"\" + dir + \"\\\": not a directory. Usage: python graphs_of_given_size.py <dataset> <collection> <dir> <min-num-nodes> <max-num-nodes>\")\n# Parse the dataset file.\ndataset = ET.parse(args.dataset).getroot()\ngraphs = [(graph.attrib[\"file\"], graph.attrib[\"class\"]) for graph in dataset]\n# Select graphs with size between min_size and max_size.\nfile = open(args.collection, \"w\")",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "dataset = ET.parse(args.dataset).getroot()\ngraphs = [(graph.attrib[\"file\"], graph.attrib[\"class\"]) for graph in dataset]\n# Select graphs with size between min_size and max_size.\nfile = open(args.collection, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor file_class in graphs:\n    size = graph_size(args.dir, file_class[0])\n    if (size >= args.min_size) and (size <= args.max_size):",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "graphs",
        "kind": 5,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "graphs = [(graph.attrib[\"file\"], graph.attrib[\"class\"]) for graph in dataset]\n# Select graphs with size between min_size and max_size.\nfile = open(args.collection, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor file_class in graphs:\n    size = graph_size(args.dir, file_class[0])\n    if (size >= args.min_size) and (size <= args.max_size):\n        file.write(\"\\n\\t<graph file=\\\"\" + file_class[0] + \"\\\" class=\\\"\" + file_class[1] + \"\\\"/>\")",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "data.collections.graphs_of_given_size",
        "description": "data.collections.graphs_of_given_size",
        "peekOfCode": "file = open(args.collection, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor file_class in graphs:\n    size = graph_size(args.dir, file_class[0])\n    if (size >= args.min_size) and (size <= args.max_size):\n        file.write(\"\\n\\t<graph file=\\\"\" + file_class[0] + \"\\\" class=\\\"\" + file_class[1] + \"\\\"/>\")\nfile.write(\"\\n</GraphCollection>\")\nfile.close()",
        "detail": "data.collections.graphs_of_given_size",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Generates a random sample of given size from a given dataset.\")\nparser.add_argument(\"dataset\", help=\"path to existing dataset file\")\nparser.add_argument(\"sample\", help=\"path to sample file to be generated by the script\")\nparser.add_argument(\"--exclude\", help=\"path to existing file that list the graphs contained in the dataset which should not appear in the sample\")\nparser.add_argument(\"--balanced\", help=\"generate sample with equal number of graphs per class\", action=\"store_true\")\ngroup = parser.add_mutually_exclusive_group(required=True)\ngroup.add_argument(\"--size\", help=\"size of sample; must be greater that 0; if larger than size of and the size of the dataset\", type=int)\ngroup.add_argument(\"--size_ratio\", help=\"size of sample divided by size of dataset; must be between 0 and 1\", type=float)\nargs = parser.parse_args()\nif args.dataset == args.sample:",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "group",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "group = parser.add_mutually_exclusive_group(required=True)\ngroup.add_argument(\"--size\", help=\"size of sample; must be greater that 0; if larger than size of and the size of the dataset\", type=int)\ngroup.add_argument(\"--size_ratio\", help=\"size of sample divided by size of dataset; must be between 0 and 1\", type=float)\nargs = parser.parse_args()\nif args.dataset == args.sample:\n\traise Exception(\"dataset file equals sample file\")\n# Collect excluded graphs.\nexcluded_graphs = set()\nif args.exclude:\n\ttree = ET.parse(args.exclude)",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "args = parser.parse_args()\nif args.dataset == args.sample:\n\traise Exception(\"dataset file equals sample file\")\n# Collect excluded graphs.\nexcluded_graphs = set()\nif args.exclude:\n\ttree = ET.parse(args.exclude)\n\texcluded_dataset = tree.getroot()\n\tfor graph in excluded_dataset:\n\t\texcluded_graphs.add(graph.attrib[\"file\"])",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "excluded_graphs",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "excluded_graphs = set()\nif args.exclude:\n\ttree = ET.parse(args.exclude)\n\texcluded_dataset = tree.getroot()\n\tfor graph in excluded_dataset:\n\t\texcluded_graphs.add(graph.attrib[\"file\"])\n# Collect the classes.\ndataset = ET.parse(args.dataset).getroot()\nclasses = set()\ngraph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\ttree",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\ttree = ET.parse(args.exclude)\n\texcluded_dataset = tree.getroot()\n\tfor graph in excluded_dataset:\n\t\texcluded_graphs.add(graph.attrib[\"file\"])\n# Collect the classes.\ndataset = ET.parse(args.dataset).getroot()\nclasses = set()\ngraph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}\nfor graph in dataset:\n\tclasses.add(graph.attrib[\"class\"])",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\texcluded_dataset",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\texcluded_dataset = tree.getroot()\n\tfor graph in excluded_dataset:\n\t\texcluded_graphs.add(graph.attrib[\"file\"])\n# Collect the classes.\ndataset = ET.parse(args.dataset).getroot()\nclasses = set()\ngraph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}\nfor graph in dataset:\n\tclasses.add(graph.attrib[\"class\"])\nnum_classes = len(classes)",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "dataset = ET.parse(args.dataset).getroot()\nclasses = set()\ngraph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}\nfor graph in dataset:\n\tclasses.add(graph.attrib[\"class\"])\nnum_classes = len(classes)\n# Collect the candidate graphs and group them w.r.t. their classes.\ncandidate_graphs = {cl : [] for cl in classes}\nfor graph in dataset:\n\tif not graph.attrib[\"file\"] in excluded_graphs:",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "classes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "classes = set()\ngraph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}\nfor graph in dataset:\n\tclasses.add(graph.attrib[\"class\"])\nnum_classes = len(classes)\n# Collect the candidate graphs and group them w.r.t. their classes.\ncandidate_graphs = {cl : [] for cl in classes}\nfor graph in dataset:\n\tif not graph.attrib[\"file\"] in excluded_graphs:\n\t\tcandidate_graphs[graph.attrib[\"class\"]].append(graph.attrib[\"file\"])",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "graph_classes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "graph_classes = {graph.attrib[\"file\"] : graph.attrib[\"class\"] for graph in dataset}\nfor graph in dataset:\n\tclasses.add(graph.attrib[\"class\"])\nnum_classes = len(classes)\n# Collect the candidate graphs and group them w.r.t. their classes.\ncandidate_graphs = {cl : [] for cl in classes}\nfor graph in dataset:\n\tif not graph.attrib[\"file\"] in excluded_graphs:\n\t\tcandidate_graphs[graph.attrib[\"class\"]].append(graph.attrib[\"file\"])\ncandidate_sizes = {cl : len(candidate_graphs[cl]) for cl in classes}",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "num_classes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "num_classes = len(classes)\n# Collect the candidate graphs and group them w.r.t. their classes.\ncandidate_graphs = {cl : [] for cl in classes}\nfor graph in dataset:\n\tif not graph.attrib[\"file\"] in excluded_graphs:\n\t\tcandidate_graphs[graph.attrib[\"class\"]].append(graph.attrib[\"file\"])\ncandidate_sizes = {cl : len(candidate_graphs[cl]) for cl in classes}\ntotal_candidate_size = sum([candidate_sizes[cl] for cl in candidate_sizes])\nmin_candidate_sizes = min([candidate_sizes[cl] for cl in candidate_sizes])\n# Determine the number of sampled graphs per class.",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "candidate_graphs",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "candidate_graphs = {cl : [] for cl in classes}\nfor graph in dataset:\n\tif not graph.attrib[\"file\"] in excluded_graphs:\n\t\tcandidate_graphs[graph.attrib[\"class\"]].append(graph.attrib[\"file\"])\ncandidate_sizes = {cl : len(candidate_graphs[cl]) for cl in classes}\ntotal_candidate_size = sum([candidate_sizes[cl] for cl in candidate_sizes])\nmin_candidate_sizes = min([candidate_sizes[cl] for cl in candidate_sizes])\n# Determine the number of sampled graphs per class.\nif args.size_ratio:\n\tif args.size_ratio < 0 or args.size_ratio > 1:",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "candidate_sizes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "candidate_sizes = {cl : len(candidate_graphs[cl]) for cl in classes}\ntotal_candidate_size = sum([candidate_sizes[cl] for cl in candidate_sizes])\nmin_candidate_sizes = min([candidate_sizes[cl] for cl in candidate_sizes])\n# Determine the number of sampled graphs per class.\nif args.size_ratio:\n\tif args.size_ratio < 0 or args.size_ratio > 1:\n\t\traise Exception(\"SIZE_RATIO must be between 0 and 1\")\n\targs.size = int(total_candidate_size * args.size_ratio)\nif args.size < 0:\n\traise Exception(\"SIZE must be greater than 0\")",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "total_candidate_size",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "total_candidate_size = sum([candidate_sizes[cl] for cl in candidate_sizes])\nmin_candidate_sizes = min([candidate_sizes[cl] for cl in candidate_sizes])\n# Determine the number of sampled graphs per class.\nif args.size_ratio:\n\tif args.size_ratio < 0 or args.size_ratio > 1:\n\t\traise Exception(\"SIZE_RATIO must be between 0 and 1\")\n\targs.size = int(total_candidate_size * args.size_ratio)\nif args.size < 0:\n\traise Exception(\"SIZE must be greater than 0\")\nif args.size > total_candidate_size:",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "min_candidate_sizes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "min_candidate_sizes = min([candidate_sizes[cl] for cl in candidate_sizes])\n# Determine the number of sampled graphs per class.\nif args.size_ratio:\n\tif args.size_ratio < 0 or args.size_ratio > 1:\n\t\traise Exception(\"SIZE_RATIO must be between 0 and 1\")\n\targs.size = int(total_candidate_size * args.size_ratio)\nif args.size < 0:\n\traise Exception(\"SIZE must be greater than 0\")\nif args.size > total_candidate_size:\n\targs.size = total_candidate_size",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\targs.size",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\targs.size = int(total_candidate_size * args.size_ratio)\nif args.size < 0:\n\traise Exception(\"SIZE must be greater than 0\")\nif args.size > total_candidate_size:\n\targs.size = total_candidate_size\n# Sample the graphs.\nsampled_graphs = []\nif args.balanced:\n\tsample_sizes = {cl : min(min_candidate_sizes, int(args.size / num_classes)) for cl in classes}\n\tsampled_graphs = [graph for cl in classes for graph in random.sample(candidate_graphs[cl], sample_sizes[cl])]",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\targs.size",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\targs.size = total_candidate_size\n# Sample the graphs.\nsampled_graphs = []\nif args.balanced:\n\tsample_sizes = {cl : min(min_candidate_sizes, int(args.size / num_classes)) for cl in classes}\n\tsampled_graphs = [graph for cl in classes for graph in random.sample(candidate_graphs[cl], sample_sizes[cl])]\nelse:\n\tsampled_graphs = random.sample([graph for cl in classes for graph in candidate_graphs[cl]], args.size)\n# Write sampled graphs to XML file.\nfile = open(args.sample, \"w\")",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "sampled_graphs",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "sampled_graphs = []\nif args.balanced:\n\tsample_sizes = {cl : min(min_candidate_sizes, int(args.size / num_classes)) for cl in classes}\n\tsampled_graphs = [graph for cl in classes for graph in random.sample(candidate_graphs[cl], sample_sizes[cl])]\nelse:\n\tsampled_graphs = random.sample([graph for cl in classes for graph in candidate_graphs[cl]], args.size)\n# Write sampled graphs to XML file.\nfile = open(args.sample, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\tsample_sizes",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\tsample_sizes = {cl : min(min_candidate_sizes, int(args.size / num_classes)) for cl in classes}\n\tsampled_graphs = [graph for cl in classes for graph in random.sample(candidate_graphs[cl], sample_sizes[cl])]\nelse:\n\tsampled_graphs = random.sample([graph for cl in classes for graph in candidate_graphs[cl]], args.size)\n# Write sampled graphs to XML file.\nfile = open(args.sample, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor graph in sampled_graphs:",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\tsampled_graphs",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\tsampled_graphs = [graph for cl in classes for graph in random.sample(candidate_graphs[cl], sample_sizes[cl])]\nelse:\n\tsampled_graphs = random.sample([graph for cl in classes for graph in candidate_graphs[cl]], args.size)\n# Write sampled graphs to XML file.\nfile = open(args.sample, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor graph in sampled_graphs:\n\tfile.write(\"\\n\\t<graph file=\\\"\" + graph + \"\\\" class=\\\"\" + graph_classes[graph] + \"\\\"/>\")",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "\tsampled_graphs",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "\tsampled_graphs = random.sample([graph for cl in classes for graph in candidate_graphs[cl]], args.size)\n# Write sampled graphs to XML file.\nfile = open(args.sample, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor graph in sampled_graphs:\n\tfile.write(\"\\n\\t<graph file=\\\"\" + graph + \"\\\" class=\\\"\" + graph_classes[graph] + \"\\\"/>\")\nfile.write(\"\\n</GraphCollection>\")\nfile.close()",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "data.collections.sample",
        "description": "data.collections.sample",
        "peekOfCode": "file = open(args.sample, \"w\")\nfile.write(\"<?xml version=\\\"1.0\\\"?>\")\nfile.write(\"\\n<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\")\nfile.write(\"\\n<GraphCollection>\")\nfor graph in sampled_graphs:\n\tfile.write(\"\\n\\t<graph file=\\\"\" + graph + \"\\\" class=\\\"\" + graph_classes[graph] + \"\\\"/>\")\nfile.write(\"\\n</GraphCollection>\")\nfile.close()",
        "detail": "data.collections.sample",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "class Tree:\n    def __init__(self, num_nodes, edge_list):\n        self.num_nodes = num_nodes\n        self.node_labels = [0 for node in range(num_nodes)]\n        self.edge_list = edge_list\n    def __repr__(self):\n        string = \"num_nodes =  \" + str(self.num_nodes) + \"\\n\"\n        string = string + \"node_labels =  \" + str(self.node_labels) + \"\\n\"\n        string = string + \"edge_list =  \" + str(self.edge_list)\n        return string",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "generate_canonical_pruefer_seq",
        "kind": 2,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "def generate_canonical_pruefer_seq(num_nodes):\n    # generate Pruefer sequence\n    pruefer_sec = []\n    for i in range(num_nodes - 2):\n        pruefer_sec.append(randint(0, num_nodes - 1))\n    # compute canonical form\n    old_to_new_id = {}\n    new_id = 0\n    for i in range(num_nodes - 2):\n        old_id = pruefer_sec[i]",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "pruefer_seq_to_tree",
        "kind": 2,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "def pruefer_seq_to_tree(pruefer_seq):\n    # collect the degrees\n    num_nodes = len(pruefer_seq) + 2\n    deg = [1 for node in range(num_nodes)]\n    for node in pruefer_seq:\n        deg[node] = deg[node] + 1\n    # collect all edges except for the last\n    edge_list = []\n    for tail in pruefer_seq:\n        for head in range(num_nodes):",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "generate_molecules",
        "kind": 2,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "def generate_molecules(num_molecules, min_num_nodes, max_num_nodes, max_num_trials = 10):\n    # create non-isomorphic Pruefer sequences\n    seqs = []\n    for i in range(num_molecules):\n        found_new_pruefer_seq = False\n        num_trials = 0\n        while (not found_new_pruefer_seq) and (num_trials < max_num_trials):\n            num_nodes = randint(min_num_nodes, max_num_nodes)\n            new_pruefer_seq = generate_canonical_pruefer_seq(num_nodes)\n            found_new_pruefer_seq = True",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "molecules",
        "kind": 5,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "molecules = generate_molecules(150, 8, 12)\nfile_names = [\"molecule_\" + str(i) + \".gxl\" for i in range(150)]\nnum_labels = [1, 4, 7, 10]\ndirs = [\"NL01\", \"NL04\", \"NL07\", \"NL10\"]\nfor dir_id in range(4):\n    for mol_id in range(150):\n        molecules[mol_id].generate_node_labels(num_labels[dir_id])\n        molecules[mol_id].write_to_gxl(dirs[dir_id], file_names[mol_id])\ncollection = open(\"../../collections/S-MOL.xml\", \"w\")\ncollection.write(\"<?xml version=\\\"1.0\\\"?>\\n\")",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "file_names",
        "kind": 5,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "file_names = [\"molecule_\" + str(i) + \".gxl\" for i in range(150)]\nnum_labels = [1, 4, 7, 10]\ndirs = [\"NL01\", \"NL04\", \"NL07\", \"NL10\"]\nfor dir_id in range(4):\n    for mol_id in range(150):\n        molecules[mol_id].generate_node_labels(num_labels[dir_id])\n        molecules[mol_id].write_to_gxl(dirs[dir_id], file_names[mol_id])\ncollection = open(\"../../collections/S-MOL.xml\", \"w\")\ncollection.write(\"<?xml version=\\\"1.0\\\"?>\\n\")\ncollection.write(\"<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\\n\")",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "num_labels",
        "kind": 5,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "num_labels = [1, 4, 7, 10]\ndirs = [\"NL01\", \"NL04\", \"NL07\", \"NL10\"]\nfor dir_id in range(4):\n    for mol_id in range(150):\n        molecules[mol_id].generate_node_labels(num_labels[dir_id])\n        molecules[mol_id].write_to_gxl(dirs[dir_id], file_names[mol_id])\ncollection = open(\"../../collections/S-MOL.xml\", \"w\")\ncollection.write(\"<?xml version=\\\"1.0\\\"?>\\n\")\ncollection.write(\"<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\\n\")\ncollection.write(\"<GraphCollection>\\n\")",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "dirs",
        "kind": 5,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "dirs = [\"NL01\", \"NL04\", \"NL07\", \"NL10\"]\nfor dir_id in range(4):\n    for mol_id in range(150):\n        molecules[mol_id].generate_node_labels(num_labels[dir_id])\n        molecules[mol_id].write_to_gxl(dirs[dir_id], file_names[mol_id])\ncollection = open(\"../../collections/S-MOL.xml\", \"w\")\ncollection.write(\"<?xml version=\\\"1.0\\\"?>\\n\")\ncollection.write(\"<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\\n\")\ncollection.write(\"<GraphCollection>\\n\")\nfor file_name in file_names:",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "data.datasets.S-MOL.generate_molecules",
        "description": "data.datasets.S-MOL.generate_molecules",
        "peekOfCode": "collection = open(\"../../collections/S-MOL.xml\", \"w\")\ncollection.write(\"<?xml version=\\\"1.0\\\"?>\\n\")\ncollection.write(\"<!DOCTYPE GraphCollection SYSTEM \\\"http://www.inf.unibz.it/~blumenthal/dtd/GraphCollection.dtd\\\">\\n\")\ncollection.write(\"<GraphCollection>\\n\")\nfor file_name in file_names:\n    collection.write(\"<graph file=\\\"\" + file_name + \"\\\" class=\\\"a\\\"/>\\n\")\ncollection.write(\"</GraphCollection>\\n\")\ncollection.close()",
        "detail": "data.datasets.S-MOL.generate_molecules",
        "documentation": {}
    },
    {
        "label": "EigenMatrixPrinter",
        "kind": 6,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "class EigenMatrixPrinter:\n\t\"Print Eigen Matrix or Array of some kind\"\n\tdef __init__(self, variety, val):\n\t\t\"Extract all the necessary information\"\n\t\t# Save the variety (presumably \"Matrix\" or \"Array\") for later usage\n\t\tself.variety = variety\n\t\t# The gdb extension does not support value template arguments - need to extract them by hand\n\t\ttype = val.type\n\t\tif type.code == gdb.TYPE_CODE_REF:\n\t\t\ttype = type.target()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "EigenQuaternionPrinter",
        "kind": 6,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "class EigenQuaternionPrinter:\n\t\"Print an Eigen Quaternion\"\n\tdef __init__(self, val):\n\t\t\"Extract all the necessary information\"\n\t\t# The gdb extension does not support value template arguments - need to extract them by hand\n\t\ttype = val.type\n\t\tif type.code == gdb.TYPE_CODE_REF:\n\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\tself.innerType = self.type.template_argument(0)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "build_eigen_dictionar",
        "kind": 2,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "def build_eigen_dictionary ():\n\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')] = lambda val: EigenQuaternionPrinter(val)\n\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')] = lambda val: EigenMatrixPrinter(\"Matrix\", val)\n\tpretty_printers_dict[re.compile('^Eigen::Array<.*>$')]  = lambda val: EigenMatrixPrinter(\"Array\",  val)\ndef register_eigen_printers(obj):\n\t\"Register eigen pretty-printers with objfile Obj\"\n\tif obj == None:\n\t\tobj = gdb\n\tobj.pretty_printers.append(lookup_function)\ndef lookup_function(val):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "register_eigen_printers",
        "kind": 2,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "def register_eigen_printers(obj):\n\t\"Register eigen pretty-printers with objfile Obj\"\n\tif obj == None:\n\t\tobj = gdb\n\tobj.pretty_printers.append(lookup_function)\ndef lookup_function(val):\n\t\"Look-up and return a pretty-printer that can print va.\"\n\ttype = val.type\n\tif type.code == gdb.TYPE_CODE_REF:\n\t\ttype = type.target()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "lookup_function",
        "kind": 2,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "def lookup_function(val):\n\t\"Look-up and return a pretty-printer that can print va.\"\n\ttype = val.type\n\tif type.code == gdb.TYPE_CODE_REF:\n\t\ttype = type.target()\n\ttype = type.unqualified().strip_typedefs()\n\ttypename = type.tag\n\tif typename == None:\n\t\treturn None\n\tfor function in pretty_printers_dict:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.variety",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.variety = variety\n\t\t# The gdb extension does not support value template arguments - need to extract them by hand\n\t\ttype = val.type\n\t\tif type.code == gdb.TYPE_CODE_REF:\n\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\ttag = self.type.tag\n\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttype = val.type\n\t\tif type.code == gdb.TYPE_CODE_REF:\n\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\ttag = self.type.tag\n\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\ttag = self.type.tag\n\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.type",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.type = type.unqualified().strip_typedefs()\n\t\ttag = self.type.tag\n\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttag",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttag = self.type.tag\n\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tregex",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tregex = re.compile('\\<.*\\>')\n\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tm",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tm = regex.findall(tag)[0][1:-1]\n\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttemplate_params",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttemplate_params = m.split(',')\n\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:\n\t\t\tself.cols = int(template_params[2])",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttemplate_params",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttemplate_params = [x.replace(\" \", \"\") for x in template_params]\n\t\tif template_params[1] == '-0x00000000000000001' or template_params[1] == '-0x000000001' or template_params[1] == '-1':\n\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:\n\t\t\tself.cols = int(template_params[2])\n\t\tself.options = 0 # default value",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.rows",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.rows = val['m_storage']['m_rows']\n\t\telse:\n\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:\n\t\t\tself.cols = int(template_params[2])\n\t\tself.options = 0 # default value\n\t\tif len(template_params) > 3:\n\t\t\tself.options = template_params[3];",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.rows",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.rows = int(template_params[1])\n\t\tif template_params[2] == '-0x00000000000000001' or template_params[2] == '-0x000000001' or template_params[2] == '-1':\n\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:\n\t\t\tself.cols = int(template_params[2])\n\t\tself.options = 0 # default value\n\t\tif len(template_params) > 3:\n\t\t\tself.options = template_params[3];\n\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.cols",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.cols = val['m_storage']['m_cols']\n\t\telse:\n\t\t\tself.cols = int(template_params[2])\n\t\tself.options = 0 # default value\n\t\tif len(template_params) > 3:\n\t\t\tself.options = template_params[3];\n\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.cols",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.cols = int(template_params[2])\n\t\tself.options = 0 # default value\n\t\tif len(template_params) > 3:\n\t\t\tself.options = template_params[3];\n\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.options",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.options = 0 # default value\n\t\tif len(template_params) > 3:\n\t\t\tself.options = template_params[3];\n\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.options",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.options = template_params[3];\n\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.rowMajor",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.rowMajor = (int(self.options) & 0x1)\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.innerType",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):\n\t\t\tself.rows = rows",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.val",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.val = val\n\t\t# Fixed size matrices have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):\n\t\t\tself.rows = rows\n\t\t\tself.cols = cols",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.data",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.data = self.val['m_storage']['m_data']\n\t\tif self.data.type.code == gdb.TYPE_CODE_STRUCT:\n\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):\n\t\t\tself.rows = rows\n\t\t\tself.cols = cols\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.data",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.data = self.data['array']\n\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):\n\t\t\tself.rows = rows\n\t\t\tself.cols = cols\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.data",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, rows, cols, dataPtr, rowMajor):\n\t\t\tself.rows = rows\n\t\t\tself.cols = cols\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.rows",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.rows = rows\n\t\t\tself.cols = cols\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.cols",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.cols = cols\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.dataPtr",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\trow = self.currentRow",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.currentRow",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.currentRow = 0\n\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\trow = self.currentRow\n\t\t\tcol = self.currentCol",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.currentCol",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.currentCol = 0\n\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\trow = self.currentRow\n\t\t\tcol = self.currentCol\n\t\t\tif self.rowMajor == 0:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.rowMajor",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.rowMajor = rowMajor\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\trow = self.currentRow\n\t\t\tcol = self.currentCol\n\t\t\tif self.rowMajor == 0:\n\t\t\t\tif self.currentCol >= self.cols:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\trow",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\trow = self.currentRow\n\t\t\tcol = self.currentCol\n\t\t\tif self.rowMajor == 0:\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\traise StopIteration\n\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\tself.currentRow = 0\n\t\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\telse:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tcol",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tcol = self.currentCol\n\t\t\tif self.rowMajor == 0:\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\traise StopIteration\n\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\tself.currentRow = 0\n\t\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\telse:\n\t\t\t\tif self.currentRow >= self.rows:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.currentRow",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\tself.currentRow = 0\n\t\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\telse:\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\traise StopIteration\n\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\tself.currentCol = 0",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.currentRow",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\t\tself.currentRow = 0\n\t\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\telse:\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\traise StopIteration\n\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\tself.currentCol = 0\n\t\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\titem = self.dataPtr.dereference()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.currentCol",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\telse:\n\t\t\t\tif self.currentRow >= self.rows:\n\t\t\t\t\traise StopIteration\n\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\tself.currentCol = 0\n\t\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.currentCol",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\tself.currentCol = self.currentCol + 1\n\t\t\t\tif self.currentCol >= self.cols:\n\t\t\t\t\tself.currentCol = 0\n\t\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\tif (self.cols == 1): #if it's a column vector\n\t\t\t\treturn ('[%d]' % (row,), item)\n\t\t\telif (self.rows == 1): #if it's a row vector\n\t\t\t\treturn ('[%d]' % (col,), item)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.currentCol",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\t\tself.currentCol = 0\n\t\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\tif (self.cols == 1): #if it's a column vector\n\t\t\t\treturn ('[%d]' % (row,), item)\n\t\t\telif (self.rows == 1): #if it's a row vector\n\t\t\t\treturn ('[%d]' % (col,), item)\n\t\t\treturn ('[%d,%d]' % (row, col), item)\n\tdef children(self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.currentRow",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\t\t\tself.currentRow = self.currentRow + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\tif (self.cols == 1): #if it's a column vector\n\t\t\t\treturn ('[%d]' % (row,), item)\n\t\t\telif (self.rows == 1): #if it's a row vector\n\t\t\t\treturn ('[%d]' % (col,), item)\n\t\t\treturn ('[%d,%d]' % (row, col), item)\n\tdef children(self):\n\t\treturn self._iterator(self.rows, self.cols, self.data, self.rowMajor)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\titem",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\tif (self.cols == 1): #if it's a column vector\n\t\t\t\treturn ('[%d]' % (row,), item)\n\t\t\telif (self.rows == 1): #if it's a row vector\n\t\t\t\treturn ('[%d]' % (col,), item)\n\t\t\treturn ('[%d,%d]' % (row, col), item)\n\tdef children(self):\n\t\treturn self._iterator(self.rows, self.cols, self.data, self.rowMajor)\n\tdef to_string(self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.dataPtr",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\tif (self.cols == 1): #if it's a column vector\n\t\t\t\treturn ('[%d]' % (row,), item)\n\t\t\telif (self.rows == 1): #if it's a row vector\n\t\t\t\treturn ('[%d]' % (col,), item)\n\t\t\treturn ('[%d,%d]' % (row, col), item)\n\tdef children(self):\n\t\treturn self._iterator(self.rows, self.cols, self.data, self.rowMajor)\n\tdef to_string(self):\n\t\treturn \"Eigen::%s<%s,%d,%d,%s> (data ptr: %s)\" % (self.variety, self.innerType, self.rows, self.cols, \"RowMajor\" if self.rowMajor else  \"ColMajor\", self.data)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttype = val.type\n\t\tif type.code == gdb.TYPE_CODE_REF:\n\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Quaternions have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\ttype = type.target()\n\t\tself.type = type.unqualified().strip_typedefs()\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Quaternions have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.type",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.type = type.unqualified().strip_typedefs()\n\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Quaternions have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.innerType",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.innerType = self.type.template_argument(0)\n\t\tself.val = val\n\t\t# Quaternions have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.val",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.val = val\n\t\t# Quaternions have a struct as their storage, so we need to walk through this\n\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.data",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.data = self.val['m_coeffs']['m_storage']['m_data']['array']\n\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tself.data",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tself.data = self.data.cast(self.innerType.pointer())\n\tclass _iterator:\n\t\tdef __init__ (self, dataPtr):\n\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.dataPtr",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.dataPtr = dataPtr\n\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\telement = self.currentElement\n\t\t\tif self.currentElement >= 4: #there are 4 elements in a quanternion",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.currentElement",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.currentElement = 0\n\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\telement = self.currentElement\n\t\t\tif self.currentElement >= 4: #there are 4 elements in a quanternion\n\t\t\t\traise StopIteration",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.elementNames",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.elementNames = ['x', 'y', 'z', 'w']\n\t\tdef __iter__ (self):\n\t\t\treturn self\n\t\tdef next(self):\n                        return self.__next__()  # Python 2.x compatibility\n\t\tdef __next__(self):\n\t\t\telement = self.currentElement\n\t\t\tif self.currentElement >= 4: #there are 4 elements in a quanternion\n\t\t\t\traise StopIteration\n\t\t\tself.currentElement = self.currentElement + 1",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\telement",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\telement = self.currentElement\n\t\t\tif self.currentElement >= 4: #there are 4 elements in a quanternion\n\t\t\t\traise StopIteration\n\t\t\tself.currentElement = self.currentElement + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\treturn ('[%s]' % (self.elementNames[element],), item)\n\tdef children(self):\n\t\treturn self._iterator(self.data)\n\tdef to_string(self):",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.currentElement",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.currentElement = self.currentElement + 1\n\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\treturn ('[%s]' % (self.elementNames[element],), item)\n\tdef children(self):\n\t\treturn self._iterator(self.data)\n\tdef to_string(self):\n\t\treturn \"Eigen::Quaternion<%s> (data ptr: %s)\" % (self.innerType, self.data)\ndef build_eigen_dictionary ():\n\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')] = lambda val: EigenQuaternionPrinter(val)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\titem",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\titem = self.dataPtr.dereference()\n\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\treturn ('[%s]' % (self.elementNames[element],), item)\n\tdef children(self):\n\t\treturn self._iterator(self.data)\n\tdef to_string(self):\n\t\treturn \"Eigen::Quaternion<%s> (data ptr: %s)\" % (self.innerType, self.data)\ndef build_eigen_dictionary ():\n\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')] = lambda val: EigenQuaternionPrinter(val)\n\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')] = lambda val: EigenMatrixPrinter(\"Matrix\", val)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.dataPtr",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\t\tself.dataPtr = self.dataPtr + 1\n\t\t\treturn ('[%s]' % (self.elementNames[element],), item)\n\tdef children(self):\n\t\treturn self._iterator(self.data)\n\tdef to_string(self):\n\t\treturn \"Eigen::Quaternion<%s> (data ptr: %s)\" % (self.innerType, self.data)\ndef build_eigen_dictionary ():\n\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')] = lambda val: EigenQuaternionPrinter(val)\n\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')] = lambda val: EigenMatrixPrinter(\"Matrix\", val)\n\tpretty_printers_dict[re.compile('^Eigen::Array<.*>$')]  = lambda val: EigenMatrixPrinter(\"Array\",  val)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')]",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\tpretty_printers_dict[re.compile('^Eigen::Quaternion<.*>$')] = lambda val: EigenQuaternionPrinter(val)\n\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')] = lambda val: EigenMatrixPrinter(\"Matrix\", val)\n\tpretty_printers_dict[re.compile('^Eigen::Array<.*>$')]  = lambda val: EigenMatrixPrinter(\"Array\",  val)\ndef register_eigen_printers(obj):\n\t\"Register eigen pretty-printers with objfile Obj\"\n\tif obj == None:\n\t\tobj = gdb\n\tobj.pretty_printers.append(lookup_function)\ndef lookup_function(val):\n\t\"Look-up and return a pretty-printer that can print va.\"",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')]",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\tpretty_printers_dict[re.compile('^Eigen::Matrix<.*>$')] = lambda val: EigenMatrixPrinter(\"Matrix\", val)\n\tpretty_printers_dict[re.compile('^Eigen::Array<.*>$')]  = lambda val: EigenMatrixPrinter(\"Array\",  val)\ndef register_eigen_printers(obj):\n\t\"Register eigen pretty-printers with objfile Obj\"\n\tif obj == None:\n\t\tobj = gdb\n\tobj.pretty_printers.append(lookup_function)\ndef lookup_function(val):\n\t\"Look-up and return a pretty-printer that can print va.\"\n\ttype = val.type",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\tobj",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\tobj = gdb\n\tobj.pretty_printers.append(lookup_function)\ndef lookup_function(val):\n\t\"Look-up and return a pretty-printer that can print va.\"\n\ttype = val.type\n\tif type.code == gdb.TYPE_CODE_REF:\n\t\ttype = type.target()\n\ttype = type.unqualified().strip_typedefs()\n\ttypename = type.tag\n\tif typename == None:",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\ttype = val.type\n\tif type.code == gdb.TYPE_CODE_REF:\n\t\ttype = type.target()\n\ttype = type.unqualified().strip_typedefs()\n\ttypename = type.tag\n\tif typename == None:\n\t\treturn None\n\tfor function in pretty_printers_dict:\n\t\tif function.search(typename):\n\t\t\treturn pretty_printers_dict[function](val)",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\t\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\t\ttype = type.target()\n\ttype = type.unqualified().strip_typedefs()\n\ttypename = type.tag\n\tif typename == None:\n\t\treturn None\n\tfor function in pretty_printers_dict:\n\t\tif function.search(typename):\n\t\t\treturn pretty_printers_dict[function](val)\n\treturn None\npretty_printers_dict = {}",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\ttype",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\ttype = type.unqualified().strip_typedefs()\n\ttypename = type.tag\n\tif typename == None:\n\t\treturn None\n\tfor function in pretty_printers_dict:\n\t\tif function.search(typename):\n\t\t\treturn pretty_printers_dict[function](val)\n\treturn None\npretty_printers_dict = {}\nbuild_eigen_dictionary ()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "\ttypename",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "\ttypename = type.tag\n\tif typename == None:\n\t\treturn None\n\tfor function in pretty_printers_dict:\n\t\tif function.search(typename):\n\t\t\treturn pretty_printers_dict[function](val)\n\treturn None\npretty_printers_dict = {}\nbuild_eigen_dictionary ()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "pretty_printers_dict",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.debug.gdb.printers",
        "description": "ext.eigen.3.3.4.debug.gdb.printers",
        "peekOfCode": "pretty_printers_dict = {}\nbuild_eigen_dictionary ()",
        "detail": "ext.eigen.3.3.4.debug.gdb.printers",
        "documentation": {}
    },
    {
        "label": "update",
        "kind": 2,
        "importPath": "ext.eigen.3.3.4.scripts.relicense",
        "description": "ext.eigen.3.3.4.scripts.relicense",
        "peekOfCode": "def update(text):\n  if text.find(lgpl3_header) == -1:\n    return text, False\n  return text.replace(lgpl3_header, mpl2_header), True\nrootdir = sys.argv[1]\nfor root, sub_folders, files in os.walk(rootdir):\n    for basename in files:\n        if basename in exclusions:\n          print 'SKIPPED', filename\n          continue",
        "detail": "ext.eigen.3.3.4.scripts.relicense",
        "documentation": {}
    },
    {
        "label": "lgpl3_header",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.scripts.relicense",
        "description": "ext.eigen.3.3.4.scripts.relicense",
        "peekOfCode": "lgpl3_header = '''\n// Eigen is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3 of the License, or (at your option) any later version.\n//\n// Alternatively, you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; either version 2 of\n// the License, or (at your option) any later version.",
        "detail": "ext.eigen.3.3.4.scripts.relicense",
        "documentation": {}
    },
    {
        "label": "mpl2_header",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.scripts.relicense",
        "description": "ext.eigen.3.3.4.scripts.relicense",
        "peekOfCode": "mpl2_header = \"\"\"\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\"\"\"\nimport os\nimport sys\nexclusions = set(['relicense.py'])\ndef update(text):\n  if text.find(lgpl3_header) == -1:",
        "detail": "ext.eigen.3.3.4.scripts.relicense",
        "documentation": {}
    },
    {
        "label": "exclusions",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.scripts.relicense",
        "description": "ext.eigen.3.3.4.scripts.relicense",
        "peekOfCode": "exclusions = set(['relicense.py'])\ndef update(text):\n  if text.find(lgpl3_header) == -1:\n    return text, False\n  return text.replace(lgpl3_header, mpl2_header), True\nrootdir = sys.argv[1]\nfor root, sub_folders, files in os.walk(rootdir):\n    for basename in files:\n        if basename in exclusions:\n          print 'SKIPPED', filename",
        "detail": "ext.eigen.3.3.4.scripts.relicense",
        "documentation": {}
    },
    {
        "label": "rootdir",
        "kind": 5,
        "importPath": "ext.eigen.3.3.4.scripts.relicense",
        "description": "ext.eigen.3.3.4.scripts.relicense",
        "peekOfCode": "rootdir = sys.argv[1]\nfor root, sub_folders, files in os.walk(rootdir):\n    for basename in files:\n        if basename in exclusions:\n          print 'SKIPPED', filename\n          continue\n        filename = os.path.join(root, basename)\n        fo = file(filename)\n        text = fo.read()\n        fo.close()",
        "detail": "ext.eigen.3.3.4.scripts.relicense",
        "documentation": {}
    },
    {
        "label": "svm_node",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "class svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "svm_problem",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "class svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):\n\t\t\traise ValueError(\"len(y) != len(x)\")\n\t\tself.l = l = len(y)\n\t\tmax_idx = 0\n\t\tx_space = self.x_space = []",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "svm_parameter",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "class svm_parameter(Structure):\n\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]\n\t_types = [c_int, c_int, c_int, c_double, c_double,\n\t\t\tc_double, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double),\n\t\t\tc_double, c_double, c_int, c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, options = None):\n\t\tif options == None:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "svm_model",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "class svm_model(Structure):\n\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),\n\t\t\tPOINTER(c_int), POINTER(c_int), c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self):\n\t\tself.__createfrom__ = 'python'",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "print_null",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "def print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "genFields",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "def genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "fillprototype",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "def fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "gen_svm_nodearray",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "def gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):\n\t\tif not isKernel:\n\t\t\txi = [0] + xi  # idx should start from 1\n\t\tindex_range = range(len(xi))\n\telse:\n\t\traise TypeError('xi should be a dictionary, list or tuple')\n\tif feature_max:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "toPyModel",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "def toPyModel(model_ptr):\n\t\"\"\"\n\ttoPyModel(model_ptr) -> svm_model\n\tConvert a ctypes POINTER(svm_model) to a Python svm_model\n\t\"\"\"\n\tif bool(model_ptr) == False:\n\t\traise ValueError(\"Null pointer\")\n\tm = model_ptr.contents\n\tm.__createfrom__ = 'C'\n\treturn m",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\txrange",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\txrange = range\n__all__ = ['libsvm', 'svm_problem', 'svm_parameter',\n           'toPyModel', 'gen_svm_nodearray', 'print_null', 'svm_node', 'C_SVC',\n           'EPSILON_SVR', 'LINEAR', 'NU_SVC', 'NU_SVR', 'ONE_CLASS',\n           'POLY', 'PRECOMPUTED', 'PRINT_STRING_FUN', 'RBF',\n           'SIGMOID', 'c_double', 'svm_model']\ntry:\n\tdirname = path.dirname(path.abspath(__file__))\n\tif sys.platform == 'win32':\n\t\tlibsvm = CDLL(path.join(dirname, r'..\\windows\\libsvm.dll'))",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "__all__ = ['libsvm', 'svm_problem', 'svm_parameter',\n           'toPyModel', 'gen_svm_nodearray', 'print_null', 'svm_node', 'C_SVC',\n           'EPSILON_SVR', 'LINEAR', 'NU_SVC', 'NU_SVR', 'ONE_CLASS',\n           'POLY', 'PRECOMPUTED', 'PRINT_STRING_FUN', 'RBF',\n           'SIGMOID', 'c_double', 'svm_model']\ntry:\n\tdirname = path.dirname(path.abspath(__file__))\n\tif sys.platform == 'win32':\n\t\tlibsvm = CDLL(path.join(dirname, r'..\\windows\\libsvm.dll'))\n\telse:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tdirname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tdirname = path.dirname(path.abspath(__file__))\n\tif sys.platform == 'win32':\n\t\tlibsvm = CDLL(path.join(dirname, r'..\\windows\\libsvm.dll'))\n\telse:\n\t\tlibsvm = CDLL(path.join(dirname, '../libsvm.so.2'))\nexcept:\n# For unix the prefix 'lib' is not considered.\n\tif find_library('svm'):\n\t\tlibsvm = CDLL(find_library('svm'))\n\telif find_library('libsvm'):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tlibsvm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tlibsvm = CDLL(path.join(dirname, r'..\\windows\\libsvm.dll'))\n\telse:\n\t\tlibsvm = CDLL(path.join(dirname, '../libsvm.so.2'))\nexcept:\n# For unix the prefix 'lib' is not considered.\n\tif find_library('svm'):\n\t\tlibsvm = CDLL(find_library('svm'))\n\telif find_library('libsvm'):\n\t\tlibsvm = CDLL(find_library('libsvm'))\n\telse:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tlibsvm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tlibsvm = CDLL(path.join(dirname, '../libsvm.so.2'))\nexcept:\n# For unix the prefix 'lib' is not considered.\n\tif find_library('svm'):\n\t\tlibsvm = CDLL(find_library('svm'))\n\telif find_library('libsvm'):\n\t\tlibsvm = CDLL(find_library('libsvm'))\n\telse:\n\t\traise Exception('LIBSVM library not found.')\nC_SVC = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tlibsvm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tlibsvm = CDLL(find_library('svm'))\n\telif find_library('libsvm'):\n\t\tlibsvm = CDLL(find_library('libsvm'))\n\telse:\n\t\traise Exception('LIBSVM library not found.')\nC_SVC = 0\nNU_SVC = 1\nONE_CLASS = 2\nEPSILON_SVR = 3\nNU_SVR = 4",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tlibsvm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tlibsvm = CDLL(find_library('libsvm'))\n\telse:\n\t\traise Exception('LIBSVM library not found.')\nC_SVC = 0\nNU_SVC = 1\nONE_CLASS = 2\nEPSILON_SVR = 3\nNU_SVR = 4\nLINEAR = 0\nPOLY = 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "C_SVC",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "C_SVC = 0\nNU_SVC = 1\nONE_CLASS = 2\nEPSILON_SVR = 3\nNU_SVR = 4\nLINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "NU_SVC",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "NU_SVC = 1\nONE_CLASS = 2\nEPSILON_SVR = 3\nNU_SVR = 4\nLINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "ONE_CLASS",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "ONE_CLASS = 2\nEPSILON_SVR = 3\nNU_SVR = 4\nLINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "EPSILON_SVR",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "EPSILON_SVR = 3\nNU_SVR = 4\nLINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "NU_SVR",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "NU_SVR = 4\nLINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "LINEAR",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "LINEAR = 0\nPOLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "POLY",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "POLY = 1\nRBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "RBF",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "RBF = 2\nSIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "SIGMOID",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "SIGMOID = 3\nPRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "PRECOMPUTED",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "PRECOMPUTED = 4\nPRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "PRINT_STRING_FUN",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "PRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)\ndef print_null(s):\n\treturn\ndef genFields(names, types):\n\treturn list(zip(names, types))\ndef fillprototype(f, restype, argtypes):\n\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tf.restype",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tf.restype = restype\n\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tf.argtypes",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tf.argtypes = argtypes\nclass svm_node(Structure):\n\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_names",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_names = [\"index\", \"value\"]\n\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):\n\t\tif not isKernel:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_types",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_types = [c_int, c_double]\n\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):\n\t\tif not isKernel:\n\t\t\txi = [0] + xi  # idx should start from 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_fields_ = genFields(_names, _types)\n\tdef __str__(self):\n\t\treturn '%d:%g' % (self.index, self.value)\ndef gen_svm_nodearray(xi, feature_max=None, isKernel=None):\n\tif isinstance(xi, dict):\n\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):\n\t\tif not isKernel:\n\t\t\txi = [0] + xi  # idx should start from 1\n\t\tindex_range = range(len(xi))",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tindex_range",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tindex_range = xi.keys()\n\telif isinstance(xi, (list, tuple)):\n\t\tif not isKernel:\n\t\t\txi = [0] + xi  # idx should start from 1\n\t\tindex_range = range(len(xi))\n\telse:\n\t\traise TypeError('xi should be a dictionary, list or tuple')\n\tif feature_max:\n\t\tassert(isinstance(feature_max, int))\n\t\tindex_range = filter(lambda j: j <= feature_max, index_range)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\txi",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\txi = [0] + xi  # idx should start from 1\n\t\tindex_range = range(len(xi))\n\telse:\n\t\traise TypeError('xi should be a dictionary, list or tuple')\n\tif feature_max:\n\t\tassert(isinstance(feature_max, int))\n\t\tindex_range = filter(lambda j: j <= feature_max, index_range)\n\tif not isKernel:\n\t\tindex_range = filter(lambda j:xi[j] != 0, index_range)\n\tindex_range = sorted(index_range)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tindex_range",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tindex_range = range(len(xi))\n\telse:\n\t\traise TypeError('xi should be a dictionary, list or tuple')\n\tif feature_max:\n\t\tassert(isinstance(feature_max, int))\n\t\tindex_range = filter(lambda j: j <= feature_max, index_range)\n\tif not isKernel:\n\t\tindex_range = filter(lambda j:xi[j] != 0, index_range)\n\tindex_range = sorted(index_range)\n\tret = (svm_node * (len(index_range)+1))()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tindex_range",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tindex_range = filter(lambda j: j <= feature_max, index_range)\n\tif not isKernel:\n\t\tindex_range = filter(lambda j:xi[j] != 0, index_range)\n\tindex_range = sorted(index_range)\n\tret = (svm_node * (len(index_range)+1))()\n\tret[-1].index = -1\n\tfor idx, j in enumerate(index_range):\n\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tindex_range",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tindex_range = filter(lambda j:xi[j] != 0, index_range)\n\tindex_range = sorted(index_range)\n\tret = (svm_node * (len(index_range)+1))()\n\tret[-1].index = -1\n\tfor idx, j in enumerate(index_range):\n\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tindex_range",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tindex_range = sorted(index_range)\n\tret = (svm_node * (len(index_range)+1))()\n\tret[-1].index = -1\n\tfor idx, j in enumerate(index_range):\n\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tret",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tret = (svm_node * (len(index_range)+1))()\n\tret[-1].index = -1\n\tfor idx, j in enumerate(index_range):\n\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tret[-1].index",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tret[-1].index = -1\n\tfor idx, j in enumerate(index_range):\n\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tret[idx].index",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tret[idx].index = j\n\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tret[idx].value",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tret[idx].value = xi[j]\n\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tmax_idx",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tmax_idx = 0\n\tif index_range:\n\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tmax_idx",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tmax_idx = index_range[-1]\n\treturn ret, max_idx\nclass svm_problem(Structure):\n\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):\n\t\t\traise ValueError(\"len(y) != len(x)\")\n\t\tself.l = l = len(y)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_names",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_names = [\"l\", \"y\", \"x\"]\n\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):\n\t\t\traise ValueError(\"len(y) != len(x)\")\n\t\tself.l = l = len(y)\n\t\tmax_idx = 0\n\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_types",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_types = [c_int, POINTER(c_double), POINTER(POINTER(svm_node))]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):\n\t\t\traise ValueError(\"len(y) != len(x)\")\n\t\tself.l = l = len(y)\n\t\tmax_idx = 0\n\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):\n\t\t\ttmp_xi, tmp_idx = gen_svm_nodearray(xi,isKernel=isKernel)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, y, x, isKernel=None):\n\t\tif len(y) != len(x):\n\t\t\traise ValueError(\"len(y) != len(x)\")\n\t\tself.l = l = len(y)\n\t\tmax_idx = 0\n\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):\n\t\t\ttmp_xi, tmp_idx = gen_svm_nodearray(xi,isKernel=isKernel)\n\t\t\tx_space += [tmp_xi]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.l",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.l = l = len(y)\n\t\tmax_idx = 0\n\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):\n\t\t\ttmp_xi, tmp_idx = gen_svm_nodearray(xi,isKernel=isKernel)\n\t\t\tx_space += [tmp_xi]\n\t\t\tmax_idx = max(max_idx, tmp_idx)\n\t\tself.n = max_idx\n\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tmax_idx",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tmax_idx = 0\n\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):\n\t\t\ttmp_xi, tmp_idx = gen_svm_nodearray(xi,isKernel=isKernel)\n\t\t\tx_space += [tmp_xi]\n\t\t\tmax_idx = max(max_idx, tmp_idx)\n\t\tself.n = max_idx\n\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi\n\t\tself.x = (POINTER(svm_node) * l)()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tx_space",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tx_space = self.x_space = []\n\t\tfor i, xi in enumerate(x):\n\t\t\ttmp_xi, tmp_idx = gen_svm_nodearray(xi,isKernel=isKernel)\n\t\t\tx_space += [tmp_xi]\n\t\t\tmax_idx = max(max_idx, tmp_idx)\n\t\tself.n = max_idx\n\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi\n\t\tself.x = (POINTER(svm_node) * l)()\n\t\tfor i, xi in enumerate(self.x_space): self.x[i] = xi",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\tmax_idx",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\tmax_idx = max(max_idx, tmp_idx)\n\t\tself.n = max_idx\n\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi\n\t\tself.x = (POINTER(svm_node) * l)()\n\t\tfor i, xi in enumerate(self.x_space): self.x[i] = xi\nclass svm_parameter(Structure):\n\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.n",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.n = max_idx\n\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi\n\t\tself.x = (POINTER(svm_node) * l)()\n\t\tfor i, xi in enumerate(self.x_space): self.x[i] = xi\nclass svm_parameter(Structure):\n\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]\n\t_types = [c_int, c_int, c_int, c_double, c_double,",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.y",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.y = (c_double * l)()\n\t\tfor i, yi in enumerate(y): self.y[i] = yi\n\t\tself.x = (POINTER(svm_node) * l)()\n\t\tfor i, xi in enumerate(self.x_space): self.x[i] = xi\nclass svm_parameter(Structure):\n\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]\n\t_types = [c_int, c_int, c_int, c_double, c_double,\n\t\t\tc_double, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double),",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.x",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.x = (POINTER(svm_node) * l)()\n\t\tfor i, xi in enumerate(self.x_space): self.x[i] = xi\nclass svm_parameter(Structure):\n\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]\n\t_types = [c_int, c_int, c_int, c_double, c_double,\n\t\t\tc_double, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double),\n\t\t\tc_double, c_double, c_int, c_int]\n\t_fields_ = genFields(_names, _types)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_names",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_names = [\"svm_type\", \"kernel_type\", \"degree\", \"gamma\", \"coef0\",\n\t\t\t\"cache_size\", \"eps\", \"C\", \"nr_weight\", \"weight_label\", \"weight\",\n\t\t\t\"nu\", \"p\", \"shrinking\", \"probability\"]\n\t_types = [c_int, c_int, c_int, c_double, c_double,\n\t\t\tc_double, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double),\n\t\t\tc_double, c_double, c_int, c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, options = None):\n\t\tif options == None:\n\t\t\toptions = ''",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_types",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_types = [c_int, c_int, c_int, c_double, c_double,\n\t\t\tc_double, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double),\n\t\t\tc_double, c_double, c_int, c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, options = None):\n\t\tif options == None:\n\t\t\toptions = ''\n\t\tself.parse_options(options)\n\tdef __str__(self):\n\t\ts = ''",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_fields_ = genFields(_names, _types)\n\tdef __init__(self, options = None):\n\t\tif options == None:\n\t\t\toptions = ''\n\t\tself.parse_options(options)\n\tdef __str__(self):\n\t\ts = ''\n\t\tattrs = svm_parameter._names + list(self.__dict__.keys())\n\t\tvalues = map(lambda attr: getattr(self, attr), attrs)\n\t\tfor attr, val in zip(attrs, values):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\toptions",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\toptions = ''\n\t\tself.parse_options(options)\n\tdef __str__(self):\n\t\ts = ''\n\t\tattrs = svm_parameter._names + list(self.__dict__.keys())\n\t\tvalues = map(lambda attr: getattr(self, attr), attrs)\n\t\tfor attr, val in zip(attrs, values):\n\t\t\ts += (' %s: %s\\n' % (attr, val))\n\t\ts = s.strip()\n\t\treturn s",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\ts",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\ts = ''\n\t\tattrs = svm_parameter._names + list(self.__dict__.keys())\n\t\tvalues = map(lambda attr: getattr(self, attr), attrs)\n\t\tfor attr, val in zip(attrs, values):\n\t\t\ts += (' %s: %s\\n' % (attr, val))\n\t\ts = s.strip()\n\t\treturn s\n\tdef set_to_default_values(self):\n\t\tself.svm_type = C_SVC;\n\t\tself.kernel_type = RBF",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tattrs",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tattrs = svm_parameter._names + list(self.__dict__.keys())\n\t\tvalues = map(lambda attr: getattr(self, attr), attrs)\n\t\tfor attr, val in zip(attrs, values):\n\t\t\ts += (' %s: %s\\n' % (attr, val))\n\t\ts = s.strip()\n\t\treturn s\n\tdef set_to_default_values(self):\n\t\tself.svm_type = C_SVC;\n\t\tself.kernel_type = RBF\n\t\tself.degree = 3",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tvalues",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tvalues = map(lambda attr: getattr(self, attr), attrs)\n\t\tfor attr, val in zip(attrs, values):\n\t\t\ts += (' %s: %s\\n' % (attr, val))\n\t\ts = s.strip()\n\t\treturn s\n\tdef set_to_default_values(self):\n\t\tself.svm_type = C_SVC;\n\t\tself.kernel_type = RBF\n\t\tself.degree = 3\n\t\tself.gamma = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\ts",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\ts = s.strip()\n\t\treturn s\n\tdef set_to_default_values(self):\n\t\tself.svm_type = C_SVC;\n\t\tself.kernel_type = RBF\n\t\tself.degree = 3\n\t\tself.gamma = 0\n\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.svm_type",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.svm_type = C_SVC;\n\t\tself.kernel_type = RBF\n\t\tself.degree = 3\n\t\tself.gamma = 0\n\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.kernel_type",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.kernel_type = RBF\n\t\tself.degree = 3\n\t\tself.gamma = 0\n\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.degree",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.degree = 3\n\t\tself.gamma = 0\n\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.gamma",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.gamma = 0\n\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.coef0",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.coef0 = 0\n\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.nu",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.nu = 0.5\n\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.cache_size",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.cache_size = 100\n\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.C",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.C = 1\n\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.eps",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.eps = 0.001\n\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.p",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.p = 0.1\n\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.shrinking",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.shrinking = 1\n\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.probability",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.probability = 0\n\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.nr_weight",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.nr_weight = 0\n\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.weight_label",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.weight_label = None\n\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.weight",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.weight = None\n\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()\n\t\telse:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.cross_validation",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.cross_validation = False\n\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()\n\t\telse:\n\t\t\traise TypeError(\"arg 1 should be a list or a str.\")",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.nr_fold",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.nr_fold = 0\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()\n\t\telse:\n\t\t\traise TypeError(\"arg 1 should be a list or a str.\")\n\t\tself.set_to_default_values()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.print_func",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\tdef parse_options(self, options):\n\t\tif isinstance(options, list):\n\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()\n\t\telse:\n\t\t\traise TypeError(\"arg 1 should be a list or a str.\")\n\t\tself.set_to_default_values()\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\targv",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\targv = options\n\t\telif isinstance(options, str):\n\t\t\targv = options.split()\n\t\telse:\n\t\t\traise TypeError(\"arg 1 should be a list or a str.\")\n\t\tself.set_to_default_values()\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\t\tweight_label = []\n\t\tweight = []\n\t\ti = 0",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\targv",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\targv = options.split()\n\t\telse:\n\t\t\traise TypeError(\"arg 1 should be a list or a str.\")\n\t\tself.set_to_default_values()\n\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\t\tweight_label = []\n\t\tweight = []\n\t\ti = 0\n\t\twhile i < len(argv):\n\t\t\tif argv[i] == \"-s\":",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.print_func",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.print_func = cast(None, PRINT_STRING_FUN)\n\t\tweight_label = []\n\t\tweight = []\n\t\ti = 0\n\t\twhile i < len(argv):\n\t\t\tif argv[i] == \"-s\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tweight_label",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tweight_label = []\n\t\tweight = []\n\t\ti = 0\n\t\twhile i < len(argv):\n\t\t\tif argv[i] == \"-s\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tweight",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tweight = []\n\t\ti = 0\n\t\twhile i < len(argv):\n\t\t\tif argv[i] == \"-s\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\ti = 0\n\t\twhile i < len(argv):\n\t\t\tif argv[i] == \"-s\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.svm_type",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.svm_type = int(argv[i])\n\t\t\telif argv[i] == \"-t\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.kernel_type",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.kernel_type = int(argv[i])\n\t\t\telif argv[i] == \"-d\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.degree",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.degree = int(argv[i])\n\t\t\telif argv[i] == \"-g\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.gamma",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.gamma = float(argv[i])\n\t\t\telif argv[i] == \"-r\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.coef0",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.coef0 = float(argv[i])\n\t\t\telif argv[i] == \"-n\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.nu",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.nu = float(argv[i])\n\t\t\telif argv[i] == \"-m\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.cache_size",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.cache_size = float(argv[i])\n\t\t\telif argv[i] == \"-c\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.C",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.C = float(argv[i])\n\t\t\telif argv[i] == \"-e\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.eps",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.eps = float(argv[i])\n\t\t\telif argv[i] == \"-p\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.p",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.p = float(argv[i])\n\t\t\telif argv[i] == \"-h\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.shrinking",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.shrinking = int(argv[i])\n\t\t\telif argv[i] == \"-b\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.probability",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.probability = int(argv[i])\n\t\t\telif argv[i] == \"-q\":\n\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")\n\t\t\telif argv[i].startswith(\"-w\"):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.print_func",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.print_func = PRINT_STRING_FUN(print_null)\n\t\t\telif argv[i] == \"-v\":\n\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")\n\t\t\telif argv[i].startswith(\"-w\"):\n\t\t\t\ti = i + 1\n\t\t\t\tself.nr_weight += 1",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")\n\t\t\telif argv[i].startswith(\"-w\"):\n\t\t\t\ti = i + 1\n\t\t\t\tself.nr_weight += 1\n\t\t\t\tweight_label += [int(argv[i-1][2:])]\n\t\t\t\tweight += [float(argv[i])]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.cross_validation",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.cross_validation = 1\n\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")\n\t\t\telif argv[i].startswith(\"-w\"):\n\t\t\t\ti = i + 1\n\t\t\t\tself.nr_weight += 1\n\t\t\t\tweight_label += [int(argv[i-1][2:])]\n\t\t\t\tweight += [float(argv[i])]\n\t\t\telse:",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.nr_fold",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\tself.nr_fold = int(argv[i])\n\t\t\t\tif self.nr_fold < 2:\n\t\t\t\t\traise ValueError(\"n-fold cross validation: n must >= 2\")\n\t\t\telif argv[i].startswith(\"-w\"):\n\t\t\t\ti = i + 1\n\t\t\t\tself.nr_weight += 1\n\t\t\t\tweight_label += [int(argv[i-1][2:])]\n\t\t\t\tweight += [float(argv[i])]\n\t\t\telse:\n\t\t\t\traise ValueError(\"Wrong options\")",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.nr_weight += 1\n\t\t\t\tweight_label += [int(argv[i-1][2:])]\n\t\t\t\tweight += [float(argv[i])]\n\t\t\telse:\n\t\t\t\traise ValueError(\"Wrong options\")\n\t\t\ti += 1\n\t\tlibsvm.svm_set_print_string_function(self.print_func)\n\t\tself.weight_label = (c_int*self.nr_weight)()\n\t\tself.weight = (c_double*self.nr_weight)()",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.weight_label",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.weight_label = (c_int*self.nr_weight)()\n\t\tself.weight = (c_double*self.nr_weight)()\n\t\tfor i in range(self.nr_weight):\n\t\t\tself.weight[i] = weight[i]\n\t\t\tself.weight_label[i] = weight_label[i]\nclass svm_model(Structure):\n\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.weight",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.weight = (c_double*self.nr_weight)()\n\t\tfor i in range(self.nr_weight):\n\t\t\tself.weight[i] = weight[i]\n\t\t\tself.weight_label[i] = weight_label[i]\nclass svm_model(Structure):\n\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.weight[i]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\tself.weight[i] = weight[i]\n\t\t\tself.weight_label[i] = weight_label[i]\nclass svm_model(Structure):\n\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),\n\t\t\tPOINTER(c_int), POINTER(c_int), c_int]\n\t_fields_ = genFields(_names, _types)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.weight_label[i]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\tself.weight_label[i] = weight_label[i]\nclass svm_model(Structure):\n\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),\n\t\t\tPOINTER(c_int), POINTER(c_int), c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_names",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_names = ['param', 'nr_class', 'l', 'SV', 'sv_coef', 'rho',\n\t\t\t'probA', 'probB', 'sv_indices', 'label', 'nSV', 'free_sv']\n\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),\n\t\t\tPOINTER(c_int), POINTER(c_int), c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self):\n\t\tself.__createfrom__ = 'python'\n\tdef __del__(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_types",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_types = [svm_parameter, c_int, c_int, POINTER(POINTER(svm_node)),\n\t\t\tPOINTER(POINTER(c_double)), POINTER(c_double),\n\t\t\tPOINTER(c_double), POINTER(c_double), POINTER(c_int),\n\t\t\tPOINTER(c_int), POINTER(c_int), c_int]\n\t_fields_ = genFields(_names, _types)\n\tdef __init__(self):\n\t\tself.__createfrom__ = 'python'\n\tdef __del__(self):\n\t\t# free memory created by C to avoid memory leak\n\t\tif hasattr(self, '__createfrom__') and self.__createfrom__ == 'C':",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t_fields_ = genFields(_names, _types)\n\tdef __init__(self):\n\t\tself.__createfrom__ = 'python'\n\tdef __del__(self):\n\t\t# free memory created by C to avoid memory leak\n\t\tif hasattr(self, '__createfrom__') and self.__createfrom__ == 'C':\n\t\t\tlibsvm.svm_free_and_destroy_model(pointer(self))\n\tdef get_svm_type(self):\n\t\treturn libsvm.svm_get_svm_type(self)\n\tdef get_nr_class(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tself.__createfrom__",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tself.__createfrom__ = 'python'\n\tdef __del__(self):\n\t\t# free memory created by C to avoid memory leak\n\t\tif hasattr(self, '__createfrom__') and self.__createfrom__ == 'C':\n\t\t\tlibsvm.svm_free_and_destroy_model(pointer(self))\n\tdef get_svm_type(self):\n\t\treturn libsvm.svm_get_svm_type(self)\n\tdef get_nr_class(self):\n\t\treturn libsvm.svm_get_nr_class(self)\n\tdef get_svr_probability(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tnr_class",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tnr_class = self.get_nr_class()\n\t\tlabels = (c_int * nr_class)()\n\t\tlibsvm.svm_get_labels(self, labels)\n\t\treturn labels[:nr_class]\n\tdef get_sv_indices(self):\n\t\ttotal_sv = self.get_nr_sv()\n\t\tsv_indices = (c_int * total_sv)()\n\t\tlibsvm.svm_get_sv_indices(self, sv_indices)\n\t\treturn sv_indices[:total_sv]\n\tdef get_nr_sv(self):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tlabels",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tlabels = (c_int * nr_class)()\n\t\tlibsvm.svm_get_labels(self, labels)\n\t\treturn labels[:nr_class]\n\tdef get_sv_indices(self):\n\t\ttotal_sv = self.get_nr_sv()\n\t\tsv_indices = (c_int * total_sv)()\n\t\tlibsvm.svm_get_sv_indices(self, sv_indices)\n\t\treturn sv_indices[:total_sv]\n\tdef get_nr_sv(self):\n\t\treturn libsvm.svm_get_nr_sv(self)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\ttotal_sv",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\ttotal_sv = self.get_nr_sv()\n\t\tsv_indices = (c_int * total_sv)()\n\t\tlibsvm.svm_get_sv_indices(self, sv_indices)\n\t\treturn sv_indices[:total_sv]\n\tdef get_nr_sv(self):\n\t\treturn libsvm.svm_get_nr_sv(self)\n\tdef is_probability_model(self):\n\t\treturn (libsvm.svm_check_probability_model(self) == 1)\n\tdef get_sv_coef(self):\n\t\treturn [tuple(self.sv_coef[j][i] for j in xrange(self.nr_class - 1))",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tsv_indices",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tsv_indices = (c_int * total_sv)()\n\t\tlibsvm.svm_get_sv_indices(self, sv_indices)\n\t\treturn sv_indices[:total_sv]\n\tdef get_nr_sv(self):\n\t\treturn libsvm.svm_get_nr_sv(self)\n\tdef is_probability_model(self):\n\t\treturn (libsvm.svm_check_probability_model(self) == 1)\n\tdef get_sv_coef(self):\n\t\treturn [tuple(self.sv_coef[j][i] for j in xrange(self.nr_class - 1))\n\t\t\t\tfor i in xrange(self.l)]",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\tresult = []\n\t\tfor sparse_sv in self.SV[:self.l]:\n\t\t\trow = dict()\n\t\t\ti = 0\n\t\t\twhile True:\n\t\t\t\trow[sparse_sv[i].index] = sparse_sv[i].value\n\t\t\t\tif sparse_sv[i].index == -1:\n\t\t\t\t\tbreak\n\t\t\t\ti += 1\n\t\t\tresult.append(row)",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\trow",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\trow = dict()\n\t\t\ti = 0\n\t\t\twhile True:\n\t\t\t\trow[sparse_sv[i].index] = sparse_sv[i].value\n\t\t\t\tif sparse_sv[i].index == -1:\n\t\t\t\t\tbreak\n\t\t\t\ti += 1\n\t\t\tresult.append(row)\n\t\treturn result\ndef toPyModel(model_ptr):",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\ti = 0\n\t\t\twhile True:\n\t\t\t\trow[sparse_sv[i].index] = sparse_sv[i].value\n\t\t\t\tif sparse_sv[i].index == -1:\n\t\t\t\t\tbreak\n\t\t\t\ti += 1\n\t\t\tresult.append(row)\n\t\treturn result\ndef toPyModel(model_ptr):\n\t\"\"\"",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\t\t\t\trow[sparse_sv[i].index]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\t\t\t\trow[sparse_sv[i].index] = sparse_sv[i].value\n\t\t\t\tif sparse_sv[i].index == -1:\n\t\t\t\t\tbreak\n\t\t\t\ti += 1\n\t\t\tresult.append(row)\n\t\treturn result\ndef toPyModel(model_ptr):\n\t\"\"\"\n\ttoPyModel(model_ptr) -> svm_model\n\tConvert a ctypes POINTER(svm_model) to a Python svm_model",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tm = model_ptr.contents\n\tm.__createfrom__ = 'C'\n\treturn m\nfillprototype(libsvm.svm_train, POINTER(svm_model), [POINTER(svm_problem), POINTER(svm_parameter)])\nfillprototype(libsvm.svm_cross_validation, None, [POINTER(svm_problem), POINTER(svm_parameter), c_int, POINTER(c_double)])\nfillprototype(libsvm.svm_save_model, c_int, [c_char_p, POINTER(svm_model)])\nfillprototype(libsvm.svm_load_model, POINTER(svm_model), [c_char_p])\nfillprototype(libsvm.svm_get_svm_type, c_int, [POINTER(svm_model)])\nfillprototype(libsvm.svm_get_nr_class, c_int, [POINTER(svm_model)])\nfillprototype(libsvm.svm_get_labels, None, [POINTER(svm_model), POINTER(c_int)])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "\tm.__createfrom__",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svm",
        "description": "ext.libsvm.3.22.python.svm",
        "peekOfCode": "\tm.__createfrom__ = 'C'\n\treturn m\nfillprototype(libsvm.svm_train, POINTER(svm_model), [POINTER(svm_problem), POINTER(svm_parameter)])\nfillprototype(libsvm.svm_cross_validation, None, [POINTER(svm_problem), POINTER(svm_parameter), c_int, POINTER(c_double)])\nfillprototype(libsvm.svm_save_model, c_int, [c_char_p, POINTER(svm_model)])\nfillprototype(libsvm.svm_load_model, POINTER(svm_model), [c_char_p])\nfillprototype(libsvm.svm_get_svm_type, c_int, [POINTER(svm_model)])\nfillprototype(libsvm.svm_get_nr_class, c_int, [POINTER(svm_model)])\nfillprototype(libsvm.svm_get_labels, None, [POINTER(svm_model), POINTER(c_int)])\nfillprototype(libsvm.svm_get_sv_indices, None, [POINTER(svm_model), POINTER(c_int)])",
        "detail": "ext.libsvm.3.22.python.svm",
        "documentation": {}
    },
    {
        "label": "svm_read_problem",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def svm_read_problem(data_file_name):\n\t\"\"\"\n\tsvm_read_problem(data_file_name) -> [y, x]\n\tRead LIBSVM-format data from data_file_name and return labels y\n\tand data instances x.\n\t\"\"\"\n\tprob_y = []\n\tprob_x = []\n\tfor line in open(data_file_name):\n\t\tline = line.split(None, 1)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "svm_load_model",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def svm_load_model(model_file_name):\n\t\"\"\"\n\tsvm_load_model(model_file_name) -> model\n\tLoad a LIBSVM model from model_file_name and return.\n\t\"\"\"\n\tmodel = libsvm.svm_load_model(model_file_name.encode())\n\tif not model:\n\t\tprint(\"can't open model file %s\" % model_file_name)\n\t\treturn None\n\tmodel = toPyModel(model)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "svm_save_model",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def svm_save_model(model_file_name, model):\n\t\"\"\"\n\tsvm_save_model(model_file_name, model) -> None\n\tSave a LIBSVM model to the file model_file_name.\n\t\"\"\"\n\tlibsvm.svm_save_model(model_file_name.encode(), model)\ndef evaluations(ty, pv):\n\t\"\"\"\n\tevaluations(ty, pv) -> (ACC, MSE, SCC)\n\tCalculate accuracy, mean squared error and squared correlation coefficient",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "evaluations",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def evaluations(ty, pv):\n\t\"\"\"\n\tevaluations(ty, pv) -> (ACC, MSE, SCC)\n\tCalculate accuracy, mean squared error and squared correlation coefficient\n\tusing the true values (ty) and predicted values (pv).\n\t\"\"\"\n\tif len(ty) != len(pv):\n\t\traise ValueError(\"len(ty) must equal to len(pv)\")\n\ttotal_correct = total_error = 0\n\tsumv = sumy = sumvv = sumyy = sumvy = 0",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "svm_train",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"\n\tsvm_train(y, x [, options]) -> model | ACC | MSE\n\tsvm_train(prob [, options]) -> model | ACC | MSE\n\tsvm_train(prob, param) -> model | ACC| MSE\n\tTrain an SVM model from data (y, x) or an svm_problem prob using\n\t'options' or an svm_parameter param.\n\tIf '-v' is specified in 'options' (i.e., cross validation)\n\teither accuracy (ACC) or mean-squared error (MSE) is returned.\n\toptions:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "svm_predict",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "def svm_predict(y, x, m, options=\"\"):\n\t\"\"\"\n\tsvm_predict(y, x, m [, options]) -> (p_labels, p_acc, p_vals)\n\tPredict data (y, x) with the SVM model m.\n\toptions:\n\t    -b probability_estimates: whether to predict probability estimates,\n\t        0 or 1 (default 0); for one-class SVM only 0 is supported.\n\t    -q : quiet mode (no outputs).\n\tThe return tuple contains\n\tp_labels: a list of predicted labels",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "__all__ = ['evaluations', 'svm_load_model', 'svm_predict', 'svm_read_problem',\n           'svm_save_model', 'svm_train'] + svm_all\nsys.path = [os.path.dirname(os.path.abspath(__file__))] + sys.path\ndef svm_read_problem(data_file_name):\n\t\"\"\"\n\tsvm_read_problem(data_file_name) -> [y, x]\n\tRead LIBSVM-format data from data_file_name and return labels y\n\tand data instances x.\n\t\"\"\"\n\tprob_y = []",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "sys.path",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "sys.path = [os.path.dirname(os.path.abspath(__file__))] + sys.path\ndef svm_read_problem(data_file_name):\n\t\"\"\"\n\tsvm_read_problem(data_file_name) -> [y, x]\n\tRead LIBSVM-format data from data_file_name and return labels y\n\tand data instances x.\n\t\"\"\"\n\tprob_y = []\n\tprob_x = []\n\tfor line in open(data_file_name):",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tprob_y",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tprob_y = []\n\tprob_x = []\n\tfor line in open(data_file_name):\n\t\tline = line.split(None, 1)\n\t\t# In case an instance with all zero features\n\t\tif len(line) == 1: line += ['']\n\t\tlabel, features = line\n\t\txi = {}\n\t\tfor e in features.split():\n\t\t\tind, val = e.split(\":\")",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tprob_x",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tprob_x = []\n\tfor line in open(data_file_name):\n\t\tline = line.split(None, 1)\n\t\t# In case an instance with all zero features\n\t\tif len(line) == 1: line += ['']\n\t\tlabel, features = line\n\t\txi = {}\n\t\tfor e in features.split():\n\t\t\tind, val = e.split(\":\")\n\t\t\txi[int(ind)] = float(val)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tline = line.split(None, 1)\n\t\t# In case an instance with all zero features\n\t\tif len(line) == 1: line += ['']\n\t\tlabel, features = line\n\t\txi = {}\n\t\tfor e in features.split():\n\t\t\tind, val = e.split(\":\")\n\t\t\txi[int(ind)] = float(val)\n\t\tprob_y += [float(label)]\n\t\tprob_x += [xi]",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\txi",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\txi = {}\n\t\tfor e in features.split():\n\t\t\tind, val = e.split(\":\")\n\t\t\txi[int(ind)] = float(val)\n\t\tprob_y += [float(label)]\n\t\tprob_x += [xi]\n\treturn (prob_y, prob_x)\ndef svm_load_model(model_file_name):\n\t\"\"\"\n\tsvm_load_model(model_file_name) -> model",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\txi[int(ind)]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\txi[int(ind)] = float(val)\n\t\tprob_y += [float(label)]\n\t\tprob_x += [xi]\n\treturn (prob_y, prob_x)\ndef svm_load_model(model_file_name):\n\t\"\"\"\n\tsvm_load_model(model_file_name) -> model\n\tLoad a LIBSVM model from model_file_name and return.\n\t\"\"\"\n\tmodel = libsvm.svm_load_model(model_file_name.encode())",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tmodel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tmodel = libsvm.svm_load_model(model_file_name.encode())\n\tif not model:\n\t\tprint(\"can't open model file %s\" % model_file_name)\n\t\treturn None\n\tmodel = toPyModel(model)\n\treturn model\ndef svm_save_model(model_file_name, model):\n\t\"\"\"\n\tsvm_save_model(model_file_name, model) -> None\n\tSave a LIBSVM model to the file model_file_name.",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tmodel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tmodel = toPyModel(model)\n\treturn model\ndef svm_save_model(model_file_name, model):\n\t\"\"\"\n\tsvm_save_model(model_file_name, model) -> None\n\tSave a LIBSVM model to the file model_file_name.\n\t\"\"\"\n\tlibsvm.svm_save_model(model_file_name.encode(), model)\ndef evaluations(ty, pv):\n\t\"\"\"",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\ttotal_correct",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\ttotal_correct = total_error = 0\n\tsumv = sumy = sumvv = sumyy = sumvy = 0\n\tfor v, y in zip(pv, ty):\n\t\tif y == v:\n\t\t\ttotal_correct += 1\n\t\ttotal_error += (v-y)*(v-y)\n\t\tsumv += v\n\t\tsumy += y\n\t\tsumvv += v*v\n\t\tsumyy += y*y",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tsumv",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tsumv = sumy = sumvv = sumyy = sumvy = 0\n\tfor v, y in zip(pv, ty):\n\t\tif y == v:\n\t\t\ttotal_correct += 1\n\t\ttotal_error += (v-y)*(v-y)\n\t\tsumv += v\n\t\tsumy += y\n\t\tsumvv += v*v\n\t\tsumyy += y*y\n\t\tsumvy += v*y",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tl",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tl = len(ty)\n\tACC = 100.0*total_correct/l\n\tMSE = total_error/l\n\ttry:\n\t\tSCC = ((l*sumvy-sumv*sumy)*(l*sumvy-sumv*sumy))/((l*sumvv-sumv*sumv)*(l*sumyy-sumy*sumy))\n\texcept:\n\t\tSCC = float('nan')\n\treturn (ACC, MSE, SCC)\ndef svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tACC",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tACC = 100.0*total_correct/l\n\tMSE = total_error/l\n\ttry:\n\t\tSCC = ((l*sumvy-sumv*sumy)*(l*sumvy-sumv*sumy))/((l*sumvv-sumv*sumv)*(l*sumyy-sumy*sumy))\n\texcept:\n\t\tSCC = float('nan')\n\treturn (ACC, MSE, SCC)\ndef svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"\n\tsvm_train(y, x [, options]) -> model | ACC | MSE",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tMSE",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tMSE = total_error/l\n\ttry:\n\t\tSCC = ((l*sumvy-sumv*sumy)*(l*sumvy-sumv*sumy))/((l*sumvv-sumv*sumv)*(l*sumyy-sumy*sumy))\n\texcept:\n\t\tSCC = float('nan')\n\treturn (ACC, MSE, SCC)\ndef svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"\n\tsvm_train(y, x [, options]) -> model | ACC | MSE\n\tsvm_train(prob [, options]) -> model | ACC | MSE",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tSCC",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tSCC = ((l*sumvy-sumv*sumy)*(l*sumvy-sumv*sumy))/((l*sumvv-sumv*sumv)*(l*sumyy-sumy*sumy))\n\texcept:\n\t\tSCC = float('nan')\n\treturn (ACC, MSE, SCC)\ndef svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"\n\tsvm_train(y, x [, options]) -> model | ACC | MSE\n\tsvm_train(prob [, options]) -> model | ACC | MSE\n\tsvm_train(prob, param) -> model | ACC| MSE\n\tTrain an SVM model from data (y, x) or an svm_problem prob using",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tSCC",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tSCC = float('nan')\n\treturn (ACC, MSE, SCC)\ndef svm_train(arg1, arg2=None, arg3=None):\n\t\"\"\"\n\tsvm_train(y, x [, options]) -> model | ACC | MSE\n\tsvm_train(prob [, options]) -> model | ACC | MSE\n\tsvm_train(prob, param) -> model | ACC| MSE\n\tTrain an SVM model from data (y, x) or an svm_problem prob using\n\t'options' or an svm_parameter param.\n\tIf '-v' is specified in 'options' (i.e., cross validation)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tparam",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tparam = svm_parameter(options)\n\t\tprob = svm_problem(y, x, isKernel=(param.kernel_type == PRECOMPUTED))\n\telif isinstance(arg1, svm_problem):\n\t\tprob = arg1\n\t\tif isinstance(arg2, svm_parameter):\n\t\t\tparam = arg2\n\t\telse:\n\t\t\tparam = svm_parameter(arg2)\n\tif prob == None or param == None:\n\t\traise TypeError(\"Wrong types for the arguments\")",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tprob",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tprob = svm_problem(y, x, isKernel=(param.kernel_type == PRECOMPUTED))\n\telif isinstance(arg1, svm_problem):\n\t\tprob = arg1\n\t\tif isinstance(arg2, svm_parameter):\n\t\t\tparam = arg2\n\t\telse:\n\t\t\tparam = svm_parameter(arg2)\n\tif prob == None or param == None:\n\t\traise TypeError(\"Wrong types for the arguments\")\n\tif param.kernel_type == PRECOMPUTED:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tprob",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tprob = arg1\n\t\tif isinstance(arg2, svm_parameter):\n\t\t\tparam = arg2\n\t\telse:\n\t\t\tparam = svm_parameter(arg2)\n\tif prob == None or param == None:\n\t\traise TypeError(\"Wrong types for the arguments\")\n\tif param.kernel_type == PRECOMPUTED:\n\t\tfor xi in prob.x_space:\n\t\t\tidx, val = xi[0].index, xi[0].value",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tparam",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tparam = arg2\n\t\telse:\n\t\t\tparam = svm_parameter(arg2)\n\tif prob == None or param == None:\n\t\traise TypeError(\"Wrong types for the arguments\")\n\tif param.kernel_type == PRECOMPUTED:\n\t\tfor xi in prob.x_space:\n\t\t\tidx, val = xi[0].index, xi[0].value\n\t\t\tif xi[0].index != 0:\n\t\t\t\traise ValueError('Wrong input format: first column must be 0:sample_serial_number')",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tparam",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tparam = svm_parameter(arg2)\n\tif prob == None or param == None:\n\t\traise TypeError(\"Wrong types for the arguments\")\n\tif param.kernel_type == PRECOMPUTED:\n\t\tfor xi in prob.x_space:\n\t\t\tidx, val = xi[0].index, xi[0].value\n\t\t\tif xi[0].index != 0:\n\t\t\t\traise ValueError('Wrong input format: first column must be 0:sample_serial_number')\n\t\t\tif val <= 0 or val > prob.n:\n\t\t\t\traise ValueError('Wrong input format: sample_serial_number out of range')",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tparam.gamma",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tparam.gamma = 1.0 / prob.n\n\tlibsvm.svm_set_print_string_function(param.print_func)\n\terr_msg = libsvm.svm_check_parameter(prob, param)\n\tif err_msg:\n\t\traise ValueError('Error: %s' % err_msg)\n\tif param.cross_validation:\n\t\tl, nr_fold = prob.l, param.nr_fold\n\t\ttarget = (c_double * l)()\n\t\tlibsvm.svm_cross_validation(prob, param, nr_fold, target)\n\t\tACC, MSE, SCC = evaluations(prob.y[:l], target[:l])",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\terr_msg",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\terr_msg = libsvm.svm_check_parameter(prob, param)\n\tif err_msg:\n\t\traise ValueError('Error: %s' % err_msg)\n\tif param.cross_validation:\n\t\tl, nr_fold = prob.l, param.nr_fold\n\t\ttarget = (c_double * l)()\n\t\tlibsvm.svm_cross_validation(prob, param, nr_fold, target)\n\t\tACC, MSE, SCC = evaluations(prob.y[:l], target[:l])\n\t\tif param.svm_type in [EPSILON_SVR, NU_SVR]:\n\t\t\tprint(\"Cross Validation Mean squared error = %g\" % MSE)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\ttarget",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\ttarget = (c_double * l)()\n\t\tlibsvm.svm_cross_validation(prob, param, nr_fold, target)\n\t\tACC, MSE, SCC = evaluations(prob.y[:l], target[:l])\n\t\tif param.svm_type in [EPSILON_SVR, NU_SVR]:\n\t\t\tprint(\"Cross Validation Mean squared error = %g\" % MSE)\n\t\t\tprint(\"Cross Validation Squared correlation coefficient = %g\" % SCC)\n\t\t\treturn MSE\n\t\telse:\n\t\t\tprint(\"Cross Validation Accuracy = %g%%\" % ACC)\n\t\t\treturn ACC",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tm = libsvm.svm_train(prob, param)\n\t\tm = toPyModel(m)\n\t\t# If prob is destroyed, data including SVs pointed by m can remain.\n\t\tm.x_space = prob.x_space\n\t\treturn m\ndef svm_predict(y, x, m, options=\"\"):\n\t\"\"\"\n\tsvm_predict(y, x, m [, options]) -> (p_labels, p_acc, p_vals)\n\tPredict data (y, x) with the SVM model m.\n\toptions:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tm",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tm = toPyModel(m)\n\t\t# If prob is destroyed, data including SVs pointed by m can remain.\n\t\tm.x_space = prob.x_space\n\t\treturn m\ndef svm_predict(y, x, m, options=\"\"):\n\t\"\"\"\n\tsvm_predict(y, x, m [, options]) -> (p_labels, p_acc, p_vals)\n\tPredict data (y, x) with the SVM model m.\n\toptions:\n\t    -b probability_estimates: whether to predict probability estimates,",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tm.x_space",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tm.x_space = prob.x_space\n\t\treturn m\ndef svm_predict(y, x, m, options=\"\"):\n\t\"\"\"\n\tsvm_predict(y, x, m [, options]) -> (p_labels, p_acc, p_vals)\n\tPredict data (y, x) with the SVM model m.\n\toptions:\n\t    -b probability_estimates: whether to predict probability estimates,\n\t        0 or 1 (default 0); for one-class SVM only 0 is supported.\n\t    -q : quiet mode (no outputs).",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tpredict_probability",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tpredict_probability = 0\n\targv = options.split()\n\ti = 0\n\twhile i < len(argv):\n\t\tif argv[i] == '-b':\n\t\t\ti += 1\n\t\t\tpredict_probability = int(argv[i])\n\t\telif argv[i] == '-q':\n\t\t\tinfo = print_null\n\t\telse:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\targv",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\targv = options.split()\n\ti = 0\n\twhile i < len(argv):\n\t\tif argv[i] == '-b':\n\t\t\ti += 1\n\t\t\tpredict_probability = int(argv[i])\n\t\telif argv[i] == '-q':\n\t\t\tinfo = print_null\n\t\telse:\n\t\t\traise ValueError(\"Wrong options\")",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\ti = 0\n\twhile i < len(argv):\n\t\tif argv[i] == '-b':\n\t\t\ti += 1\n\t\t\tpredict_probability = int(argv[i])\n\t\telif argv[i] == '-q':\n\t\t\tinfo = print_null\n\t\telse:\n\t\t\traise ValueError(\"Wrong options\")\n\t\ti+=1",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tpredict_probability",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tpredict_probability = int(argv[i])\n\t\telif argv[i] == '-q':\n\t\t\tinfo = print_null\n\t\telse:\n\t\t\traise ValueError(\"Wrong options\")\n\t\ti+=1\n\tsvm_type = m.get_svm_type()\n\tis_prob_model = m.is_probability_model()\n\tnr_class = m.get_nr_class()\n\tpred_labels = []",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tinfo",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tinfo = print_null\n\t\telse:\n\t\t\traise ValueError(\"Wrong options\")\n\t\ti+=1\n\tsvm_type = m.get_svm_type()\n\tis_prob_model = m.is_probability_model()\n\tnr_class = m.get_nr_class()\n\tpred_labels = []\n\tpred_values = []\n\tif predict_probability:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tsvm_type",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tsvm_type = m.get_svm_type()\n\tis_prob_model = m.is_probability_model()\n\tnr_class = m.get_nr_class()\n\tpred_labels = []\n\tpred_values = []\n\tif predict_probability:\n\t\tif not is_prob_model:\n\t\t\traise ValueError(\"Model does not support probabiliy estimates\")\n\t\tif svm_type in [NU_SVR, EPSILON_SVR]:\n\t\t\tinfo(\"Prob. model for test data: target value = predicted value + z,\\n\"",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tis_prob_model",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tis_prob_model = m.is_probability_model()\n\tnr_class = m.get_nr_class()\n\tpred_labels = []\n\tpred_values = []\n\tif predict_probability:\n\t\tif not is_prob_model:\n\t\t\traise ValueError(\"Model does not support probabiliy estimates\")\n\t\tif svm_type in [NU_SVR, EPSILON_SVR]:\n\t\t\tinfo(\"Prob. model for test data: target value = predicted value + z,\\n\"\n\t\t\t\"z: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma=%g\" % m.get_svr_probability());",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tnr_class",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tnr_class = m.get_nr_class()\n\tpred_labels = []\n\tpred_values = []\n\tif predict_probability:\n\t\tif not is_prob_model:\n\t\t\traise ValueError(\"Model does not support probabiliy estimates\")\n\t\tif svm_type in [NU_SVR, EPSILON_SVR]:\n\t\t\tinfo(\"Prob. model for test data: target value = predicted value + z,\\n\"\n\t\t\t\"z: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma=%g\" % m.get_svr_probability());\n\t\t\tnr_class = 0",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tpred_labels",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tpred_labels = []\n\tpred_values = []\n\tif predict_probability:\n\t\tif not is_prob_model:\n\t\t\traise ValueError(\"Model does not support probabiliy estimates\")\n\t\tif svm_type in [NU_SVR, EPSILON_SVR]:\n\t\t\tinfo(\"Prob. model for test data: target value = predicted value + z,\\n\"\n\t\t\t\"z: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma=%g\" % m.get_svr_probability());\n\t\t\tnr_class = 0\n\t\tprob_estimates = (c_double * nr_class)()",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tpred_values",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tpred_values = []\n\tif predict_probability:\n\t\tif not is_prob_model:\n\t\t\traise ValueError(\"Model does not support probabiliy estimates\")\n\t\tif svm_type in [NU_SVR, EPSILON_SVR]:\n\t\t\tinfo(\"Prob. model for test data: target value = predicted value + z,\\n\"\n\t\t\t\"z: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma=%g\" % m.get_svr_probability());\n\t\t\tnr_class = 0\n\t\tprob_estimates = (c_double * nr_class)()\n\t\tfor xi in x:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tnr_class",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tnr_class = 0\n\t\tprob_estimates = (c_double * nr_class)()\n\t\tfor xi in x:\n\t\t\txi, idx = gen_svm_nodearray(xi, isKernel=(m.param.kernel_type == PRECOMPUTED))\n\t\t\tlabel = libsvm.svm_predict_probability(m, xi, prob_estimates)\n\t\t\tvalues = prob_estimates[:nr_class]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\telse:\n\t\tif is_prob_model:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tprob_estimates",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tprob_estimates = (c_double * nr_class)()\n\t\tfor xi in x:\n\t\t\txi, idx = gen_svm_nodearray(xi, isKernel=(m.param.kernel_type == PRECOMPUTED))\n\t\t\tlabel = libsvm.svm_predict_probability(m, xi, prob_estimates)\n\t\t\tvalues = prob_estimates[:nr_class]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\telse:\n\t\tif is_prob_model:\n\t\t\tinfo(\"Model supports probability estimates, but disabled in predicton.\")",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tlabel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tlabel = libsvm.svm_predict_probability(m, xi, prob_estimates)\n\t\t\tvalues = prob_estimates[:nr_class]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\telse:\n\t\tif is_prob_model:\n\t\t\tinfo(\"Model supports probability estimates, but disabled in predicton.\")\n\t\tif svm_type in (ONE_CLASS, EPSILON_SVR, NU_SVC):\n\t\t\tnr_classifier = 1\n\t\telse:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tvalues",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tvalues = prob_estimates[:nr_class]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\telse:\n\t\tif is_prob_model:\n\t\t\tinfo(\"Model supports probability estimates, but disabled in predicton.\")\n\t\tif svm_type in (ONE_CLASS, EPSILON_SVR, NU_SVC):\n\t\t\tnr_classifier = 1\n\t\telse:\n\t\t\tnr_classifier = nr_class*(nr_class-1)//2",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tnr_classifier",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tnr_classifier = 1\n\t\telse:\n\t\t\tnr_classifier = nr_class*(nr_class-1)//2\n\t\tdec_values = (c_double * nr_classifier)()\n\t\tfor xi in x:\n\t\t\txi, idx = gen_svm_nodearray(xi, isKernel=(m.param.kernel_type == PRECOMPUTED))\n\t\t\tlabel = libsvm.svm_predict_values(m, xi, dec_values)\n\t\t\tif(nr_class == 1):\n\t\t\t\tvalues = [1]\n\t\t\telse:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tnr_classifier",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tnr_classifier = nr_class*(nr_class-1)//2\n\t\tdec_values = (c_double * nr_classifier)()\n\t\tfor xi in x:\n\t\t\txi, idx = gen_svm_nodearray(xi, isKernel=(m.param.kernel_type == PRECOMPUTED))\n\t\t\tlabel = libsvm.svm_predict_values(m, xi, dec_values)\n\t\t\tif(nr_class == 1):\n\t\t\t\tvalues = [1]\n\t\t\telse:\n\t\t\t\tvalues = dec_values[:nr_classifier]\n\t\t\tpred_labels += [label]",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tdec_values",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tdec_values = (c_double * nr_classifier)()\n\t\tfor xi in x:\n\t\t\txi, idx = gen_svm_nodearray(xi, isKernel=(m.param.kernel_type == PRECOMPUTED))\n\t\t\tlabel = libsvm.svm_predict_values(m, xi, dec_values)\n\t\t\tif(nr_class == 1):\n\t\t\t\tvalues = [1]\n\t\t\telse:\n\t\t\t\tvalues = dec_values[:nr_classifier]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\tlabel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\tlabel = libsvm.svm_predict_values(m, xi, dec_values)\n\t\t\tif(nr_class == 1):\n\t\t\t\tvalues = [1]\n\t\t\telse:\n\t\t\t\tvalues = dec_values[:nr_classifier]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\tACC, MSE, SCC = evaluations(y, pred_labels)\n\tl = len(y)\n\tif svm_type in [EPSILON_SVR, NU_SVR]:",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tvalues",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\t\tvalues = [1]\n\t\t\telse:\n\t\t\t\tvalues = dec_values[:nr_classifier]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\tACC, MSE, SCC = evaluations(y, pred_labels)\n\tl = len(y)\n\tif svm_type in [EPSILON_SVR, NU_SVR]:\n\t\tinfo(\"Mean squared error = %g (regression)\" % MSE)\n\t\tinfo(\"Squared correlation coefficient = %g (regression)\" % SCC)",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tvalues",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\t\t\tvalues = dec_values[:nr_classifier]\n\t\t\tpred_labels += [label]\n\t\t\tpred_values += [values]\n\tACC, MSE, SCC = evaluations(y, pred_labels)\n\tl = len(y)\n\tif svm_type in [EPSILON_SVR, NU_SVR]:\n\t\tinfo(\"Mean squared error = %g (regression)\" % MSE)\n\t\tinfo(\"Squared correlation coefficient = %g (regression)\" % SCC)\n\telse:\n\t\tinfo(\"Accuracy = %g%% (%d/%d) (classification)\" % (ACC, int(l*ACC/100), l))",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\tl",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\tl = len(y)\n\tif svm_type in [EPSILON_SVR, NU_SVR]:\n\t\tinfo(\"Mean squared error = %g (regression)\" % MSE)\n\t\tinfo(\"Squared correlation coefficient = %g (regression)\" % SCC)\n\telse:\n\t\tinfo(\"Accuracy = %g%% (%d/%d) (classification)\" % (ACC, int(l*ACC/100), l))\n\treturn pred_labels, (ACC, MSE, SCC), pred_values",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "\t\tinfo(\"Accuracy",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.python.svmutil",
        "description": "ext.libsvm.3.22.python.svmutil",
        "peekOfCode": "\t\tinfo(\"Accuracy = %g%% (%d/%d) (classification)\" % (ACC, int(l*ACC/100), l))\n\treturn pred_labels, (ACC, MSE, SCC), pred_values",
        "detail": "ext.libsvm.3.22.python.svmutil",
        "documentation": {}
    },
    {
        "label": "err",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "def err(line_no, msg):\n\tprint(\"line {0}: {1}\".format(line_no, msg))\n# works like float() but does not accept nan and inf\ndef my_float(x):\n\tif x.lower().find(\"nan\") != -1 or x.lower().find(\"inf\") != -1:\n\t\traise ValueError\n\treturn float(x)\ndef main():\n\tif len(argv) != 2:\n\t\tprint(\"Usage: {0} dataset\".format(argv[0]))",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "my_float",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "def my_float(x):\n\tif x.lower().find(\"nan\") != -1 or x.lower().find(\"inf\") != -1:\n\t\traise ValueError\n\treturn float(x)\ndef main():\n\tif len(argv) != 2:\n\t\tprint(\"Usage: {0} dataset\".format(argv[0]))\n\t\texit(1)\n\tdataset = argv[1]\n\tif not os.path.exists(dataset):",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "def main():\n\tif len(argv) != 2:\n\t\tprint(\"Usage: {0} dataset\".format(argv[0]))\n\t\texit(1)\n\tdataset = argv[1]\n\tif not os.path.exists(dataset):\n\t\tprint(\"dataset {0} not found\".format(dataset))\n\t\texit(1)\n\tline_no = 1\n\terror_line_count = 0",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\tdataset",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\tdataset = argv[1]\n\tif not os.path.exists(dataset):\n\t\tprint(\"dataset {0} not found\".format(dataset))\n\t\texit(1)\n\tline_no = 1\n\terror_line_count = 0\n\tfor line in open(dataset, 'r'):\n\t\tline_error = False\n\t\t# each line must end with a newline character\n\t\tif line[-1] != '\\n':",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\tline_no",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\tline_no = 1\n\terror_line_count = 0\n\tfor line in open(dataset, 'r'):\n\t\tline_error = False\n\t\t# each line must end with a newline character\n\t\tif line[-1] != '\\n':\n\t\t\terr(line_no, \"missing a newline character in the end\")\n\t\t\tline_error = True\n\t\tnodes = line.split()\n\t\t# check label",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\terror_line_count",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\terror_line_count = 0\n\tfor line in open(dataset, 'r'):\n\t\tline_error = False\n\t\t# each line must end with a newline character\n\t\tif line[-1] != '\\n':\n\t\t\terr(line_no, \"missing a newline character in the end\")\n\t\t\tline_error = True\n\t\tnodes = line.split()\n\t\t# check label\n\t\ttry:",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\tline_error = False\n\t\t# each line must end with a newline character\n\t\tif line[-1] != '\\n':\n\t\t\terr(line_no, \"missing a newline character in the end\")\n\t\t\tline_error = True\n\t\tnodes = line.split()\n\t\t# check label\n\t\ttry:\n\t\t\tlabel = nodes.pop(0)\n\t\t\tif label.find(',') != -1:",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\tline_error = True\n\t\tnodes = line.split()\n\t\t# check label\n\t\ttry:\n\t\t\tlabel = nodes.pop(0)\n\t\t\tif label.find(',') != -1:\n\t\t\t\t# multi-label format\n\t\t\t\ttry:\n\t\t\t\t\tfor l in label.split(','):\n\t\t\t\t\t\tl = my_float(l)",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\tnodes",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\tnodes = line.split()\n\t\t# check label\n\t\ttry:\n\t\t\tlabel = nodes.pop(0)\n\t\t\tif label.find(',') != -1:\n\t\t\t\t# multi-label format\n\t\t\t\ttry:\n\t\t\t\t\tfor l in label.split(','):\n\t\t\t\t\t\tl = my_float(l)\n\t\t\t\texcept:",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\tlabel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\tlabel = nodes.pop(0)\n\t\t\tif label.find(',') != -1:\n\t\t\t\t# multi-label format\n\t\t\t\ttry:\n\t\t\t\t\tfor l in label.split(','):\n\t\t\t\t\t\tl = my_float(l)\n\t\t\t\texcept:\n\t\t\t\t\terr(line_no, \"label {0} is not a valid multi-label form\".format(label))\n\t\t\t\t\tline_error = True\n\t\t\telse:",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tl",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\t\tl = my_float(l)\n\t\t\t\texcept:\n\t\t\t\t\terr(line_no, \"label {0} is not a valid multi-label form\".format(label))\n\t\t\t\t\tline_error = True\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tlabel = my_float(label)\n\t\t\t\texcept:\n\t\t\t\t\terr(line_no, \"label {0} is not a number\".format(label))\n\t\t\t\t\tline_error = True",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\tline_error = True\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tlabel = my_float(label)\n\t\t\t\texcept:\n\t\t\t\t\terr(line_no, \"label {0} is not a number\".format(label))\n\t\t\t\t\tline_error = True\n\t\texcept:\n\t\t\terr(line_no, \"missing label, perhaps an empty line?\")\n\t\t\tline_error = True",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tlabel",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\tlabel = my_float(label)\n\t\t\t\texcept:\n\t\t\t\t\terr(line_no, \"label {0} is not a number\".format(label))\n\t\t\t\t\tline_error = True\n\t\texcept:\n\t\t\terr(line_no, \"missing label, perhaps an empty line?\")\n\t\t\tline_error = True\n\t\t# check features\n\t\tprev_index = -1\n\t\tfor i in range(len(nodes)):",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\tline_error = True\n\t\texcept:\n\t\t\terr(line_no, \"missing label, perhaps an empty line?\")\n\t\t\tline_error = True\n\t\t# check features\n\t\tprev_index = -1\n\t\tfor i in range(len(nodes)):\n\t\t\ttry:\n\t\t\t\t(index, value) =  nodes[i].split(':')\n\t\t\t\tindex = int(index)",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\tline_error = True\n\t\t# check features\n\t\tprev_index = -1\n\t\tfor i in range(len(nodes)):\n\t\t\ttry:\n\t\t\t\t(index, value) =  nodes[i].split(':')\n\t\t\t\tindex = int(index)\n\t\t\t\tvalue = my_float(value)\n\t\t\t\t# precomputed kernel's index starts from 0 and LIBSVM\n\t\t\t\t# checks it. Hence, don't treat index 0 as an error.",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\tprev_index",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\tprev_index = -1\n\t\tfor i in range(len(nodes)):\n\t\t\ttry:\n\t\t\t\t(index, value) =  nodes[i].split(':')\n\t\t\t\tindex = int(index)\n\t\t\t\tvalue = my_float(value)\n\t\t\t\t# precomputed kernel's index starts from 0 and LIBSVM\n\t\t\t\t# checks it. Hence, don't treat index 0 as an error.\n\t\t\t\tif index < 0:\n\t\t\t\t\terr(line_no, \"feature index must be positive; wrong feature {0}\".format(nodes[i]))",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tindex",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\tindex = int(index)\n\t\t\t\tvalue = my_float(value)\n\t\t\t\t# precomputed kernel's index starts from 0 and LIBSVM\n\t\t\t\t# checks it. Hence, don't treat index 0 as an error.\n\t\t\t\tif index < 0:\n\t\t\t\t\terr(line_no, \"feature index must be positive; wrong feature {0}\".format(nodes[i]))\n\t\t\t\t\tline_error = True\n\t\t\t\telif index <= prev_index:\n\t\t\t\t\terr(line_no, \"feature indices must be in an ascending order, previous/current features {0} {1}\".format(nodes[i-1], nodes[i]))\n\t\t\t\t\tline_error = True",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tvalue",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\tvalue = my_float(value)\n\t\t\t\t# precomputed kernel's index starts from 0 and LIBSVM\n\t\t\t\t# checks it. Hence, don't treat index 0 as an error.\n\t\t\t\tif index < 0:\n\t\t\t\t\terr(line_no, \"feature index must be positive; wrong feature {0}\".format(nodes[i]))\n\t\t\t\t\tline_error = True\n\t\t\t\telif index <= prev_index:\n\t\t\t\t\terr(line_no, \"feature indices must be in an ascending order, previous/current features {0} {1}\".format(nodes[i-1], nodes[i]))\n\t\t\t\t\tline_error = True\n\t\t\t\tprev_index = index",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\tline_error = True\n\t\t\t\telif index <= prev_index:\n\t\t\t\t\terr(line_no, \"feature indices must be in an ascending order, previous/current features {0} {1}\".format(nodes[i-1], nodes[i]))\n\t\t\t\t\tline_error = True\n\t\t\t\tprev_index = index\n\t\t\texcept:\n\t\t\t\terr(line_no, \"feature '{0}' not an <index>:<value> pair, <index> integer, <value> real number \".format(nodes[i]))\n\t\t\t\tline_error = True\n\t\tline_no += 1\n\t\tif line_error:",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\t\tline_error = True\n\t\t\t\tprev_index = index\n\t\t\texcept:\n\t\t\t\terr(line_no, \"feature '{0}' not an <index>:<value> pair, <index> integer, <value> real number \".format(nodes[i]))\n\t\t\t\tline_error = True\n\t\tline_no += 1\n\t\tif line_error:\n\t\t\terror_line_count += 1\n\tif error_line_count > 0:\n\t\tprint(\"Found {0} lines with error.\".format(error_line_count))",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprev_index",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\tprev_index = index\n\t\t\texcept:\n\t\t\t\terr(line_no, \"feature '{0}' not an <index>:<value> pair, <index> integer, <value> real number \".format(nodes[i]))\n\t\t\t\tline_error = True\n\t\tline_no += 1\n\t\tif line_error:\n\t\t\terror_line_count += 1\n\tif error_line_count > 0:\n\t\tprint(\"Found {0} lines with error.\".format(error_line_count))\n\t\treturn 1",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline_error",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.checkdata",
        "description": "ext.libsvm.3.22.tools.checkdata",
        "peekOfCode": "\t\t\t\tline_error = True\n\t\tline_no += 1\n\t\tif line_error:\n\t\t\terror_line_count += 1\n\tif error_line_count > 0:\n\t\tprint(\"Found {0} lines with error.\".format(error_line_count))\n\t\treturn 1\n\telse:\n\t\tprint(\"No error.\")\n\t\treturn 0",
        "detail": "ext.libsvm.3.22.tools.checkdata",
        "documentation": {}
    },
    {
        "label": "is_win32",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "is_win32 = (sys.platform == 'win32')\nif not is_win32:\n\tsvmscale_exe = \"../svm-scale\"\n\tsvmtrain_exe = \"../svm-train\"\n\tsvmpredict_exe = \"../svm-predict\"\n\tgrid_py = \"./grid.py\"\n\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmscale_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmscale_exe = \"../svm-scale\"\n\tsvmtrain_exe = \"../svm-train\"\n\tsvmpredict_exe = \"../svm-predict\"\n\tgrid_py = \"./grid.py\"\n\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmtrain_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmtrain_exe = \"../svm-train\"\n\tsvmpredict_exe = \"../svm-predict\"\n\tgrid_py = \"./grid.py\"\n\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmpredict_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmpredict_exe = \"../svm-predict\"\n\tgrid_py = \"./grid.py\"\n\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tgrid_py",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tgrid_py = \"./grid.py\"\n\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tgnuplot_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tgnuplot_exe = \"/usr/bin/gnuplot\"\nelse:\n        # example for windows\n\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmscale_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmscale_exe = r\"..\\windows\\svm-scale.exe\"\n\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"\nassert os.path.exists(svmpredict_exe),\"svm-predict executable not found\"\nassert os.path.exists(gnuplot_exe),\"gnuplot executable not found\"\nassert os.path.exists(grid_py),\"grid.py not found\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmtrain_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmtrain_exe = r\"..\\windows\\svm-train.exe\"\n\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"\nassert os.path.exists(svmpredict_exe),\"svm-predict executable not found\"\nassert os.path.exists(gnuplot_exe),\"gnuplot executable not found\"\nassert os.path.exists(grid_py),\"grid.py not found\"\ntrain_pathname = sys.argv[1]",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tsvmpredict_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tsvmpredict_exe = r\"..\\windows\\svm-predict.exe\"\n\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"\nassert os.path.exists(svmpredict_exe),\"svm-predict executable not found\"\nassert os.path.exists(gnuplot_exe),\"gnuplot executable not found\"\nassert os.path.exists(grid_py),\"grid.py not found\"\ntrain_pathname = sys.argv[1]\nassert os.path.exists(train_pathname),\"training file not found\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tgnuplot_exe",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tgnuplot_exe = r\"c:\\tmp\\gnuplot\\binary\\pgnuplot.exe\"\n\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"\nassert os.path.exists(svmpredict_exe),\"svm-predict executable not found\"\nassert os.path.exists(gnuplot_exe),\"gnuplot executable not found\"\nassert os.path.exists(grid_py),\"grid.py not found\"\ntrain_pathname = sys.argv[1]\nassert os.path.exists(train_pathname),\"training file not found\"\nfile_name = os.path.split(train_pathname)[1]",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tgrid_py",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tgrid_py = r\".\\grid.py\"\nassert os.path.exists(svmscale_exe),\"svm-scale executable not found\"\nassert os.path.exists(svmtrain_exe),\"svm-train executable not found\"\nassert os.path.exists(svmpredict_exe),\"svm-predict executable not found\"\nassert os.path.exists(gnuplot_exe),\"gnuplot executable not found\"\nassert os.path.exists(grid_py),\"grid.py not found\"\ntrain_pathname = sys.argv[1]\nassert os.path.exists(train_pathname),\"training file not found\"\nfile_name = os.path.split(train_pathname)[1]\nscaled_file = file_name + \".scale\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "train_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "train_pathname = sys.argv[1]\nassert os.path.exists(train_pathname),\"training file not found\"\nfile_name = os.path.split(train_pathname)[1]\nscaled_file = file_name + \".scale\"\nmodel_file = file_name + \".model\"\nrange_file = file_name + \".range\"\nif len(sys.argv) > 2:\n\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "file_name",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "file_name = os.path.split(train_pathname)[1]\nscaled_file = file_name + \".scale\"\nmodel_file = file_name + \".model\"\nrange_file = file_name + \".range\"\nif len(sys.argv) > 2:\n\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "scaled_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "scaled_file = file_name + \".scale\"\nmodel_file = file_name + \".model\"\nrange_file = file_name + \".range\"\nif len(sys.argv) > 2:\n\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "model_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "model_file = file_name + \".model\"\nrange_file = file_name + \".range\"\nif len(sys.argv) > 2:\n\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "range_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "range_file = file_name + \".range\"\nif len(sys.argv) > 2:\n\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\ttest_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\ttest_pathname = sys.argv[2]\n\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t\ncmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tfile_name",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tfile_name = os.path.split(test_pathname)[1]\n\tassert os.path.exists(test_pathname),\"testing file not found\"\n\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t\ncmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')\nf = Popen(cmd, shell = True, stdout = PIPE).stdout",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tscaled_test_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tscaled_test_file = file_name + \".scale\"\n\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t\ncmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')\nf = Popen(cmd, shell = True, stdout = PIPE).stdout\nline = ''\nwhile True:",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tpredict_test_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tpredict_test_file = file_name + \".predict\"\ncmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t\ncmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')\nf = Popen(cmd, shell = True, stdout = PIPE).stdout\nline = ''\nwhile True:\n\tlast_line = line",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "cmd = '{0} -s \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, train_pathname, scaled_file)\nprint('Scaling training data...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\t\ncmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')\nf = Popen(cmd, shell = True, stdout = PIPE).stdout\nline = ''\nwhile True:\n\tlast_line = line\n\tline = f.readline()",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "cmd = '{0} -svmtrain \"{1}\" -gnuplot \"{2}\" \"{3}\"'.format(grid_py, svmtrain_exe, gnuplot_exe, scaled_file)\nprint('Cross validation...')\nf = Popen(cmd, shell = True, stdout = PIPE).stdout\nline = ''\nwhile True:\n\tlast_line = line\n\tline = f.readline()\n\tif not line: break\nc,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "f = Popen(cmd, shell = True, stdout = PIPE).stdout\nline = ''\nwhile True:\n\tlast_line = line\n\tline = f.readline()\n\tif not line: break\nc,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))\ncmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "line",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "line = ''\nwhile True:\n\tlast_line = line\n\tline = f.readline()\n\tif not line: break\nc,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))\ncmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tlast_line",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tlast_line = line\n\tline = f.readline()\n\tif not line: break\nc,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))\ncmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\nprint('Output model: {0}'.format(model_file))\nif len(sys.argv) > 2:",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tline = f.readline()\n\tif not line: break\nc,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))\ncmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\nprint('Output model: {0}'.format(model_file))\nif len(sys.argv) > 2:\n\tcmd = '{0} -r \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, test_pathname, scaled_test_file)",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "c,g,rate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "c,g,rate = map(float,last_line.split())\nprint('Best c={0}, g={1} CV rate={2}'.format(c,g,rate))\ncmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\nprint('Output model: {0}'.format(model_file))\nif len(sys.argv) > 2:\n\tcmd = '{0} -r \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, test_pathname, scaled_test_file)\n\tprint('Scaling testing data...')\n\tPopen(cmd, shell = True, stdout = PIPE).communicate()\t",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "cmd = '{0} -c {1} -g {2} \"{3}\" \"{4}\"'.format(svmtrain_exe,c,g,scaled_file,model_file)\nprint('Training...')\nPopen(cmd, shell = True, stdout = PIPE).communicate()\nprint('Output model: {0}'.format(model_file))\nif len(sys.argv) > 2:\n\tcmd = '{0} -r \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, test_pathname, scaled_test_file)\n\tprint('Scaling testing data...')\n\tPopen(cmd, shell = True, stdout = PIPE).communicate()\t\n\tcmd = '{0} \"{1}\" \"{2}\" \"{3}\"'.format(svmpredict_exe, scaled_test_file, model_file, predict_test_file)\n\tprint('Testing...')",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tcmd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tcmd = '{0} -r \"{1}\" \"{2}\" > \"{3}\"'.format(svmscale_exe, range_file, test_pathname, scaled_test_file)\n\tprint('Scaling testing data...')\n\tPopen(cmd, shell = True, stdout = PIPE).communicate()\t\n\tcmd = '{0} \"{1}\" \"{2}\" \"{3}\"'.format(svmpredict_exe, scaled_test_file, model_file, predict_test_file)\n\tprint('Testing...')\n\tPopen(cmd, shell = True).communicate()\t\n\tprint('Output prediction: {0}'.format(predict_test_file))",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "\tcmd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.easy",
        "description": "ext.libsvm.3.22.tools.easy",
        "peekOfCode": "\tcmd = '{0} \"{1}\" \"{2}\" \"{3}\"'.format(svmpredict_exe, scaled_test_file, model_file, predict_test_file)\n\tprint('Testing...')\n\tPopen(cmd, shell = True).communicate()\t\n\tprint('Output prediction: {0}'.format(predict_test_file))",
        "detail": "ext.libsvm.3.22.tools.easy",
        "documentation": {}
    },
    {
        "label": "GridOption",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class GridOption:\n\tdef __init__(self, dataset_pathname, options):\n\t\tdirname = os.path.dirname(__file__)\n\t\tif sys.platform != 'win32':\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')\n\t\t\t# svmtrain_pathname = r'c:\\Program Files\\libsvm\\windows\\svm-train.exe'",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "WorkerStopToken",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass\nclass Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):\n\t\tThread.__init__(self)\n\t\tself.name = name\n\t\tself.job_queue = job_queue\n\t\tself.result_queue = result_queue\n\t\tself.options = options\n\tdef run(self):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "Worker",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):\n\t\tThread.__init__(self)\n\t\tself.name = name\n\t\tself.job_queue = job_queue\n\t\tself.result_queue = result_queue\n\t\tself.options = options\n\tdef run(self):\n\t\twhile True:\n\t\t\t(cexp,gexp) = self.job_queue.get()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "LocalWorker",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class LocalWorker(Worker):\n\tdef run_one(self,c,g):\n\t\tcmdline = self.get_cmd(c,g)\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass SSHWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "SSHWorker",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class SSHWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host\n\t\tself.cwd = os.getcwd()\n\tdef run_one(self,c,g):\n\t\tcmdline = 'ssh -x -t -t {0} \"cd {1}; {2}\"'.format\\\n\t\t\t(self.host,self.cwd,self.get_cmd(c,g))\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "TelnetWorker",
        "kind": 6,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "class TelnetWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,username,password,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host\n\t\tself.username = username\n\t\tself.password = password\t\t\n\tdef run(self):\n\t\timport telnetlib\n\t\tself.tn = tn = telnetlib.Telnet(self.host)\n\t\ttn.read_until('login: ')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "redraw",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "def redraw(db,best_param,gnuplot,options,tofile=False):\n\tif len(db) == 0: return\n\tbegin_level = round(max(x[2] for x in db)) - 3\n\tstep_size = 0.5\n\tbest_log2c,best_log2g,best_rate = best_param\n\t# if newly obtained c, g, or cv values are the same,\n\t# then stop redrawing the contour.\n\tif all(x[0] == db[0][0]  for x in db): return\n\tif all(x[1] == db[0][1]  for x in db): return\n\tif all(x[2] == db[0][2]  for x in db): return",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "calculate_jobs",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "def calculate_jobs(options):\n\tdef range_f(begin,end,step):\n\t\t# like range, but works on non-integer too\n\t\tseq = []\n\t\twhile True:\n\t\t\tif step > 0 and begin > end: break\n\t\t\tif step < 0 and begin < end: break\n\t\t\tseq.append(begin)\n\t\t\tbegin = begin + step\n\t\treturn seq",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "find_parameters",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "def find_parameters(dataset_pathname, options=''):\n\tdef update_param(c,g,rate,best_c,best_g,best_rate,worker,resumed):\n\t\tif (rate > best_rate) or (rate==best_rate and g==best_g and c<best_c):\n\t\t\tbest_rate,best_c,best_g = rate,c,g\n\t\tstdout_str = '[{0}] {1} {2} (best '.format\\\n\t\t\t(worker,' '.join(str(x) for x in [c,g] if x is not None),rate)\n\t\toutput_str = ''\n\t\tif c != None:\n\t\t\tstdout_str += 'c={0}, '.format(2.0**best_c)\n\t\t\toutput_str += 'log2c={0} '.format(c)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "__all__ = ['find_parameters']\nimport os, sys, traceback, getpass, time, re\nfrom threading import Thread\nfrom subprocess import *\nif sys.version_info[0] < 3:\n\tfrom Queue import Queue\nelse:\n\tfrom queue import Queue\ntelnet_workers = []\nssh_workers = []",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "telnet_workers",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "telnet_workers = []\nssh_workers = []\nnr_local_worker = 1\nclass GridOption:\n\tdef __init__(self, dataset_pathname, options):\n\t\tdirname = os.path.dirname(__file__)\n\t\tif sys.platform != 'win32':\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "ssh_workers",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "ssh_workers = []\nnr_local_worker = 1\nclass GridOption:\n\tdef __init__(self, dataset_pathname, options):\n\t\tdirname = os.path.dirname(__file__)\n\t\tif sys.platform != 'win32':\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "nr_local_worker",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "nr_local_worker = 1\nclass GridOption:\n\tdef __init__(self, dataset_pathname, options):\n\t\tdirname = os.path.dirname(__file__)\n\t\tif sys.platform != 'win32':\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tdirname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tdirname = os.path.dirname(__file__)\n\t\tif sys.platform != 'win32':\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')\n\t\t\t# svmtrain_pathname = r'c:\\Program Files\\libsvm\\windows\\svm-train.exe'\n\t\t\tself.gnuplot_pathname = r'c:\\tmp\\gnuplot\\binary\\pgnuplot.exe'\n\t\tself.fold = 5",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.svmtrain_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tself.svmtrain_pathname = os.path.join(dirname, '../svm-train')\n\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')\n\t\t\t# svmtrain_pathname = r'c:\\Program Files\\libsvm\\windows\\svm-train.exe'\n\t\t\tself.gnuplot_pathname = r'c:\\tmp\\gnuplot\\binary\\pgnuplot.exe'\n\t\tself.fold = 5\n\t\tself.c_begin, self.c_end, self.c_step = -5,  15,  2\n\t\tself.g_begin, self.g_end, self.g_step =  3, -15, -2",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.gnuplot_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tself.gnuplot_pathname = '/usr/bin/gnuplot'\n\t\telse:\n\t\t\t# example for windows\n\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')\n\t\t\t# svmtrain_pathname = r'c:\\Program Files\\libsvm\\windows\\svm-train.exe'\n\t\t\tself.gnuplot_pathname = r'c:\\tmp\\gnuplot\\binary\\pgnuplot.exe'\n\t\tself.fold = 5\n\t\tself.c_begin, self.c_end, self.c_step = -5,  15,  2\n\t\tself.g_begin, self.g_end, self.g_step =  3, -15, -2\n\t\tself.grid_with_c, self.grid_with_g = True, True",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.svmtrain_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tself.svmtrain_pathname = os.path.join(dirname, r'..\\windows\\svm-train.exe')\n\t\t\t# svmtrain_pathname = r'c:\\Program Files\\libsvm\\windows\\svm-train.exe'\n\t\t\tself.gnuplot_pathname = r'c:\\tmp\\gnuplot\\binary\\pgnuplot.exe'\n\t\tself.fold = 5\n\t\tself.c_begin, self.c_end, self.c_step = -5,  15,  2\n\t\tself.g_begin, self.g_end, self.g_step =  3, -15, -2\n\t\tself.grid_with_c, self.grid_with_g = True, True\n\t\tself.dataset_pathname = dataset_pathname\n\t\tself.dataset_title = os.path.split(dataset_pathname)[1]\n\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.gnuplot_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tself.gnuplot_pathname = r'c:\\tmp\\gnuplot\\binary\\pgnuplot.exe'\n\t\tself.fold = 5\n\t\tself.c_begin, self.c_end, self.c_step = -5,  15,  2\n\t\tself.g_begin, self.g_end, self.g_step =  3, -15, -2\n\t\tself.grid_with_c, self.grid_with_g = True, True\n\t\tself.dataset_pathname = dataset_pathname\n\t\tself.dataset_title = os.path.split(dataset_pathname)[1]\n\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)\n\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.fold",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.fold = 5\n\t\tself.c_begin, self.c_end, self.c_step = -5,  15,  2\n\t\tself.g_begin, self.g_end, self.g_step =  3, -15, -2\n\t\tself.grid_with_c, self.grid_with_g = True, True\n\t\tself.dataset_pathname = dataset_pathname\n\t\tself.dataset_title = os.path.split(dataset_pathname)[1]\n\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)\n\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.dataset_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.dataset_pathname = dataset_pathname\n\t\tself.dataset_title = os.path.split(dataset_pathname)[1]\n\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)\n\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.dataset_title",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.dataset_title = os.path.split(dataset_pathname)[1]\n\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)\n\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()\n\t\ti = 0",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.out_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.out_pathname = '{0}.out'.format(self.dataset_title)\n\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()\n\t\ti = 0\n\t\tpass_through_options = []",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.png_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.png_pathname = '{0}.png'.format(self.dataset_title)\n\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()\n\t\ti = 0\n\t\tpass_through_options = []\n\t\twhile i < len(options):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.pass_through_string",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.pass_through_string = ' '\n\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()\n\t\ti = 0\n\t\tpass_through_options = []\n\t\twhile i < len(options):\n\t\t\tif options[i] == '-log2c':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.resume_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.resume_pathname = None\n\t\tself.parse_options(options)\n\tdef parse_options(self, options):\n\t\tif type(options) == str:\n\t\t\toptions = options.split()\n\t\ti = 0\n\t\tpass_through_options = []\n\t\twhile i < len(options):\n\t\t\tif options[i] == '-log2c':\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\toptions",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\toptions = options.split()\n\t\ti = 0\n\t\tpass_through_options = []\n\t\twhile i < len(options):\n\t\t\tif options[i] == '-log2c':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_c = False\n\t\t\t\telse:\n\t\t\t\t\tself.c_begin, self.c_end, self.c_step = map(float,options[i].split(','))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\ti = 0\n\t\tpass_through_options = []\n\t\twhile i < len(options):\n\t\t\tif options[i] == '-log2c':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_c = False\n\t\t\t\telse:\n\t\t\t\t\tself.c_begin, self.c_end, self.c_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-log2g':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tpass_through_options",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tpass_through_options = []\n\t\twhile i < len(options):\n\t\t\tif options[i] == '-log2c':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_c = False\n\t\t\t\telse:\n\t\t\t\t\tself.c_begin, self.c_end, self.c_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-log2g':\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_c = False\n\t\t\t\telse:\n\t\t\t\t\tself.c_begin, self.c_end, self.c_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-log2g':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_g = False\n\t\t\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.grid_with_c",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.grid_with_c = False\n\t\t\t\telse:\n\t\t\t\t\tself.c_begin, self.c_end, self.c_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-log2g':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_g = False\n\t\t\t\telse:\n\t\t\t\t\tself.g_begin, self.g_end, self.g_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-v':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.grid_with_g = False\n\t\t\t\telse:\n\t\t\t\t\tself.g_begin, self.g_end, self.g_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-v':\n\t\t\t\ti = i + 1\n\t\t\t\tself.fold = options[i]\n\t\t\telif options[i] in ('-c','-g'):\n\t\t\t\traise ValueError('Use -log2c and -log2g.')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.grid_with_g",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.grid_with_g = False\n\t\t\t\telse:\n\t\t\t\t\tself.g_begin, self.g_end, self.g_step = map(float,options[i].split(','))\n\t\t\telif options[i] == '-v':\n\t\t\t\ti = i + 1\n\t\t\t\tself.fold = options[i]\n\t\t\telif options[i] in ('-c','-g'):\n\t\t\t\traise ValueError('Use -log2c and -log2g.')\n\t\t\telif options[i] == '-svmtrain':\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.fold = options[i]\n\t\t\telif options[i] in ('-c','-g'):\n\t\t\t\traise ValueError('Use -log2c and -log2g.')\n\t\t\telif options[i] == '-svmtrain':\n\t\t\t\ti = i + 1\n\t\t\t\tself.svmtrain_pathname = options[i]\n\t\t\telif options[i] == '-gnuplot':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.fold",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\tself.fold = options[i]\n\t\t\telif options[i] in ('-c','-g'):\n\t\t\t\traise ValueError('Use -log2c and -log2g.')\n\t\t\telif options[i] == '-svmtrain':\n\t\t\t\ti = i + 1\n\t\t\t\tself.svmtrain_pathname = options[i]\n\t\t\telif options[i] == '-gnuplot':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.gnuplot_pathname = None",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.svmtrain_pathname = options[i]\n\t\t\telif options[i] == '-gnuplot':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.gnuplot_pathname = None\n\t\t\t\telse:\t\n\t\t\t\t\tself.gnuplot_pathname = options[i]\n\t\t\telif options[i] == '-out':\n\t\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.svmtrain_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\tself.svmtrain_pathname = options[i]\n\t\t\telif options[i] == '-gnuplot':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.gnuplot_pathname = None\n\t\t\t\telse:\t\n\t\t\t\t\tself.gnuplot_pathname = options[i]\n\t\t\telif options[i] == '-out':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.gnuplot_pathname = None\n\t\t\t\telse:\t\n\t\t\t\t\tself.gnuplot_pathname = options[i]\n\t\t\telif options[i] == '-out':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.out_pathname = None\n\t\t\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.gnuplot_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.gnuplot_pathname = None\n\t\t\t\telse:\t\n\t\t\t\t\tself.gnuplot_pathname = options[i]\n\t\t\telif options[i] == '-out':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.out_pathname = None\n\t\t\t\telse:\n\t\t\t\t\tself.out_pathname = options[i]\n\t\t\telif options[i] == '-png':",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.gnuplot_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.gnuplot_pathname = options[i]\n\t\t\telif options[i] == '-out':\n\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.out_pathname = None\n\t\t\t\telse:\n\t\t\t\t\tself.out_pathname = options[i]\n\t\t\telif options[i] == '-png':\n\t\t\t\ti = i + 1\n\t\t\t\tself.png_pathname = options[i]",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tif options[i] == 'null':\n\t\t\t\t\tself.out_pathname = None\n\t\t\t\telse:\n\t\t\t\t\tself.out_pathname = options[i]\n\t\t\telif options[i] == '-png':\n\t\t\t\ti = i + 1\n\t\t\t\tself.png_pathname = options[i]\n\t\t\telif options[i] == '-resume':\n\t\t\t\tif i == (len(options)-1) or options[i+1].startswith('-'):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.out_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.out_pathname = None\n\t\t\t\telse:\n\t\t\t\t\tself.out_pathname = options[i]\n\t\t\telif options[i] == '-png':\n\t\t\t\ti = i + 1\n\t\t\t\tself.png_pathname = options[i]\n\t\t\telif options[i] == '-resume':\n\t\t\t\tif i == (len(options)-1) or options[i+1].startswith('-'):\n\t\t\t\t\tself.resume_pathname = self.dataset_title + '.out'\n\t\t\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.out_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.out_pathname = options[i]\n\t\t\telif options[i] == '-png':\n\t\t\t\ti = i + 1\n\t\t\t\tself.png_pathname = options[i]\n\t\t\telif options[i] == '-resume':\n\t\t\t\tif i == (len(options)-1) or options[i+1].startswith('-'):\n\t\t\t\t\tself.resume_pathname = self.dataset_title + '.out'\n\t\t\t\telse:\n\t\t\t\t\ti = i + 1\n\t\t\t\t\tself.resume_pathname = options[i]",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\ti = i + 1\n\t\t\t\tself.png_pathname = options[i]\n\t\t\telif options[i] == '-resume':\n\t\t\t\tif i == (len(options)-1) or options[i+1].startswith('-'):\n\t\t\t\t\tself.resume_pathname = self.dataset_title + '.out'\n\t\t\t\telse:\n\t\t\t\t\ti = i + 1\n\t\t\t\t\tself.resume_pathname = options[i]\n\t\t\telse:\n\t\t\t\tpass_through_options.append(options[i])",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tself.png_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\tself.png_pathname = options[i]\n\t\t\telif options[i] == '-resume':\n\t\t\t\tif i == (len(options)-1) or options[i+1].startswith('-'):\n\t\t\t\t\tself.resume_pathname = self.dataset_title + '.out'\n\t\t\t\telse:\n\t\t\t\t\ti = i + 1\n\t\t\t\t\tself.resume_pathname = options[i]\n\t\t\telse:\n\t\t\t\tpass_through_options.append(options[i])\n\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.resume_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.resume_pathname = self.dataset_title + '.out'\n\t\t\t\telse:\n\t\t\t\t\ti = i + 1\n\t\t\t\t\tself.resume_pathname = options[i]\n\t\t\telse:\n\t\t\t\tpass_through_options.append(options[i])\n\t\t\ti = i + 1\n\t\tself.pass_through_string = ' '.join(pass_through_options)\n\t\tif not os.path.exists(self.svmtrain_pathname):\n\t\t\traise IOError('svm-train executable not found')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\ti = i + 1\n\t\t\t\t\tself.resume_pathname = options[i]\n\t\t\telse:\n\t\t\t\tpass_through_options.append(options[i])\n\t\t\ti = i + 1\n\t\tself.pass_through_string = ' '.join(pass_through_options)\n\t\tif not os.path.exists(self.svmtrain_pathname):\n\t\t\traise IOError('svm-train executable not found')\n\t\tif not os.path.exists(self.dataset_pathname):\n\t\t\traise IOError('dataset not found')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tself.resume_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tself.resume_pathname = options[i]\n\t\t\telse:\n\t\t\t\tpass_through_options.append(options[i])\n\t\t\ti = i + 1\n\t\tself.pass_through_string = ' '.join(pass_through_options)\n\t\tif not os.path.exists(self.svmtrain_pathname):\n\t\t\traise IOError('svm-train executable not found')\n\t\tif not os.path.exists(self.dataset_pathname):\n\t\t\traise IOError('dataset not found')\n\t\tif self.resume_pathname and not os.path.exists(self.resume_pathname):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\ti = i + 1\n\t\tself.pass_through_string = ' '.join(pass_through_options)\n\t\tif not os.path.exists(self.svmtrain_pathname):\n\t\t\traise IOError('svm-train executable not found')\n\t\tif not os.path.exists(self.dataset_pathname):\n\t\t\traise IOError('dataset not found')\n\t\tif self.resume_pathname and not os.path.exists(self.resume_pathname):\n\t\t\traise IOError('file for resumption not found')\n\t\tif not self.grid_with_c and not self.grid_with_g:\n\t\t\traise ValueError('-log2c and -log2g should not be null simultaneously')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.pass_through_string",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.pass_through_string = ' '.join(pass_through_options)\n\t\tif not os.path.exists(self.svmtrain_pathname):\n\t\t\traise IOError('svm-train executable not found')\n\t\tif not os.path.exists(self.dataset_pathname):\n\t\t\traise IOError('dataset not found')\n\t\tif self.resume_pathname and not os.path.exists(self.resume_pathname):\n\t\t\traise IOError('file for resumption not found')\n\t\tif not self.grid_with_c and not self.grid_with_g:\n\t\t\traise ValueError('-log2c and -log2g should not be null simultaneously')\n\t\tif self.gnuplot_pathname and not os.path.exists(self.gnuplot_pathname):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.gnuplot_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tself.gnuplot_pathname = None\ndef redraw(db,best_param,gnuplot,options,tofile=False):\n\tif len(db) == 0: return\n\tbegin_level = round(max(x[2] for x in db)) - 3\n\tstep_size = 0.5\n\tbest_log2c,best_log2g,best_rate = best_param\n\t# if newly obtained c, g, or cv values are the same,\n\t# then stop redrawing the contour.\n\tif all(x[0] == db[0][0]  for x in db): return\n\tif all(x[1] == db[0][1]  for x in db): return",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tbegin_level",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tbegin_level = round(max(x[2] for x in db)) - 3\n\tstep_size = 0.5\n\tbest_log2c,best_log2g,best_rate = best_param\n\t# if newly obtained c, g, or cv values are the same,\n\t# then stop redrawing the contour.\n\tif all(x[0] == db[0][0]  for x in db): return\n\tif all(x[1] == db[0][1]  for x in db): return\n\tif all(x[2] == db[0][2]  for x in db): return\n\tif tofile:\n\t\tgnuplot.write(b\"set term png transparent small linewidth 2 medium enhanced\\n\")",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tstep_size",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tstep_size = 0.5\n\tbest_log2c,best_log2g,best_rate = best_param\n\t# if newly obtained c, g, or cv values are the same,\n\t# then stop redrawing the contour.\n\tif all(x[0] == db[0][0]  for x in db): return\n\tif all(x[1] == db[0][1]  for x in db): return\n\tif all(x[2] == db[0][2]  for x in db): return\n\tif tofile:\n\t\tgnuplot.write(b\"set term png transparent small linewidth 2 medium enhanced\\n\")\n\t\tgnuplot.write(\"set output \\\"{0}\\\"\\n\".format(options.png_pathname.replace('\\\\','\\\\\\\\')).encode())",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tbest_log2c,best_log2g,best_rate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tbest_log2c,best_log2g,best_rate = best_param\n\t# if newly obtained c, g, or cv values are the same,\n\t# then stop redrawing the contour.\n\tif all(x[0] == db[0][0]  for x in db): return\n\tif all(x[1] == db[0][1]  for x in db): return\n\tif all(x[2] == db[0][2]  for x in db): return\n\tif tofile:\n\t\tgnuplot.write(b\"set term png transparent small linewidth 2 medium enhanced\\n\")\n\t\tgnuplot.write(\"set output \\\"{0}\\\"\\n\".format(options.png_pathname.replace('\\\\','\\\\\\\\')).encode())\n\t\t#gnuplot.write(b\"set term postscript color solid\\n\")",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tdb.sort(key",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tdb.sort(key = lambda x:(x[0], -x[1]))\n\tprevc = db[0][0]\n\tfor line in db:\n\t\tif prevc != line[0]:\n\t\t\tgnuplot.write(b\"\\n\")\n\t\t\tprevc = line[0]\n\t\tgnuplot.write(\"{0[0]} {0[1]} {0[2]}\\n\".format(line).encode())\n\tgnuplot.write(b\"e\\n\")\n\tgnuplot.write(b\"\\n\") # force gnuplot back to prompt when term set failure\n\tgnuplot.flush()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tprevc",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tprevc = db[0][0]\n\tfor line in db:\n\t\tif prevc != line[0]:\n\t\t\tgnuplot.write(b\"\\n\")\n\t\t\tprevc = line[0]\n\t\tgnuplot.write(\"{0[0]} {0[1]} {0[2]}\\n\".format(line).encode())\n\tgnuplot.write(b\"e\\n\")\n\tgnuplot.write(b\"\\n\") # force gnuplot back to prompt when term set failure\n\tgnuplot.flush()\ndef calculate_jobs(options):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tprevc",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tprevc = line[0]\n\t\tgnuplot.write(\"{0[0]} {0[1]} {0[2]}\\n\".format(line).encode())\n\tgnuplot.write(b\"e\\n\")\n\tgnuplot.write(b\"\\n\") # force gnuplot back to prompt when term set failure\n\tgnuplot.flush()\ndef calculate_jobs(options):\n\tdef range_f(begin,end,step):\n\t\t# like range, but works on non-integer too\n\t\tseq = []\n\t\twhile True:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tseq",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tseq = []\n\t\twhile True:\n\t\t\tif step > 0 and begin > end: break\n\t\t\tif step < 0 and begin < end: break\n\t\t\tseq.append(begin)\n\t\t\tbegin = begin + step\n\t\treturn seq\n\tdef permute_sequence(seq):\n\t\tn = len(seq)\n\t\tif n <= 1: return seq",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tbegin",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tbegin = begin + step\n\t\treturn seq\n\tdef permute_sequence(seq):\n\t\tn = len(seq)\n\t\tif n <= 1: return seq\n\t\tmid = int(n/2)\n\t\tleft = permute_sequence(seq[:mid])\n\t\tright = permute_sequence(seq[mid+1:])\n\t\tret = [seq[mid]]\n\t\twhile left or right:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tn",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tn = len(seq)\n\t\tif n <= 1: return seq\n\t\tmid = int(n/2)\n\t\tleft = permute_sequence(seq[:mid])\n\t\tright = permute_sequence(seq[mid+1:])\n\t\tret = [seq[mid]]\n\t\twhile left or right:\n\t\t\tif left: ret.append(left.pop(0))\n\t\t\tif right: ret.append(right.pop(0))\n\t\treturn ret\t",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tmid",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tmid = int(n/2)\n\t\tleft = permute_sequence(seq[:mid])\n\t\tright = permute_sequence(seq[mid+1:])\n\t\tret = [seq[mid]]\n\t\twhile left or right:\n\t\t\tif left: ret.append(left.pop(0))\n\t\t\tif right: ret.append(right.pop(0))\n\t\treturn ret\t\n\tc_seq = permute_sequence(range_f(options.c_begin,options.c_end,options.c_step))\n\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tleft",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tleft = permute_sequence(seq[:mid])\n\t\tright = permute_sequence(seq[mid+1:])\n\t\tret = [seq[mid]]\n\t\twhile left or right:\n\t\t\tif left: ret.append(left.pop(0))\n\t\t\tif right: ret.append(right.pop(0))\n\t\treturn ret\t\n\tc_seq = permute_sequence(range_f(options.c_begin,options.c_end,options.c_step))\n\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))\n\tif not options.grid_with_c:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tright",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tright = permute_sequence(seq[mid+1:])\n\t\tret = [seq[mid]]\n\t\twhile left or right:\n\t\t\tif left: ret.append(left.pop(0))\n\t\t\tif right: ret.append(right.pop(0))\n\t\treturn ret\t\n\tc_seq = permute_sequence(range_f(options.c_begin,options.c_end,options.c_step))\n\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))\n\tif not options.grid_with_c:\n\t\tc_seq = [None]",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tret",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tret = [seq[mid]]\n\t\twhile left or right:\n\t\t\tif left: ret.append(left.pop(0))\n\t\t\tif right: ret.append(right.pop(0))\n\t\treturn ret\t\n\tc_seq = permute_sequence(range_f(options.c_begin,options.c_end,options.c_step))\n\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))\n\tif not options.grid_with_c:\n\t\tc_seq = [None]\n\tif not options.grid_with_g:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tc_seq",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tc_seq = permute_sequence(range_f(options.c_begin,options.c_end,options.c_step))\n\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))\n\tif not options.grid_with_c:\n\t\tc_seq = [None]\n\tif not options.grid_with_g:\n\t\tg_seq = [None] \n\tnr_c = float(len(c_seq))\n\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tg_seq",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tg_seq = permute_sequence(range_f(options.g_begin,options.g_end,options.g_step))\n\tif not options.grid_with_c:\n\t\tc_seq = [None]\n\tif not options.grid_with_g:\n\t\tg_seq = [None] \n\tnr_c = float(len(c_seq))\n\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []\n\twhile i < nr_c or j < nr_g:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tc_seq",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tc_seq = [None]\n\tif not options.grid_with_g:\n\t\tg_seq = [None] \n\tnr_c = float(len(c_seq))\n\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []\n\twhile i < nr_c or j < nr_g:\n\t\tif i/nr_c < j/nr_g:\n\t\t\t# increase C resolution",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tg_seq",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tg_seq = [None] \n\tnr_c = float(len(c_seq))\n\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []\n\twhile i < nr_c or j < nr_g:\n\t\tif i/nr_c < j/nr_g:\n\t\t\t# increase C resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,j):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tnr_c",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tnr_c = float(len(c_seq))\n\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []\n\twhile i < nr_c or j < nr_g:\n\t\tif i/nr_c < j/nr_g:\n\t\t\t# increase C resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,j):\n\t\t\t\tline.append((c_seq[i],g_seq[k]))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tnr_g",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tnr_g = float(len(g_seq))\n\ti, j = 0, 0\n\tjobs = []\n\twhile i < nr_c or j < nr_g:\n\t\tif i/nr_c < j/nr_g:\n\t\t\t# increase C resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,j):\n\t\t\t\tline.append((c_seq[i],g_seq[k]))\n\t\t\ti = i + 1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tjobs",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tjobs = []\n\twhile i < nr_c or j < nr_g:\n\t\tif i/nr_c < j/nr_g:\n\t\t\t# increase C resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,j):\n\t\t\t\tline.append((c_seq[i],g_seq[k]))\n\t\t\ti = i + 1\n\t\t\tjobs.append(line)\n\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tline = []\n\t\t\tfor k in range(0,j):\n\t\t\t\tline.append((c_seq[i],g_seq[k]))\n\t\t\ti = i + 1\n\t\t\tjobs.append(line)\n\t\telse:\n\t\t\t# increase g resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,i):\n\t\t\t\tline.append((c_seq[k],g_seq[j]))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\ti = i + 1\n\t\t\tjobs.append(line)\n\t\telse:\n\t\t\t# increase g resolution\n\t\t\tline = []\n\t\t\tfor k in range(0,i):\n\t\t\t\tline.append((c_seq[k],g_seq[j]))\n\t\t\tj = j + 1\n\t\t\tjobs.append(line)\n\tresumed_jobs = {}",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tline = []\n\t\t\tfor k in range(0,i):\n\t\t\t\tline.append((c_seq[k],g_seq[j]))\n\t\t\tj = j + 1\n\t\t\tjobs.append(line)\n\tresumed_jobs = {}\n\tif options.resume_pathname is None:\n\t\treturn jobs, resumed_jobs\n\tfor line in open(options.resume_pathname, 'r'):\n\t\tline = line.strip()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tj",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tj = j + 1\n\t\t\tjobs.append(line)\n\tresumed_jobs = {}\n\tif options.resume_pathname is None:\n\t\treturn jobs, resumed_jobs\n\tfor line in open(options.resume_pathname, 'r'):\n\t\tline = line.strip()\n\t\trst = re.findall(r'rate=([0-9.]+)',line)\n\t\tif not rst: \n\t\t\tcontinue",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tresumed_jobs",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tresumed_jobs = {}\n\tif options.resume_pathname is None:\n\t\treturn jobs, resumed_jobs\n\tfor line in open(options.resume_pathname, 'r'):\n\t\tline = line.strip()\n\t\trst = re.findall(r'rate=([0-9.]+)',line)\n\t\tif not rst: \n\t\t\tcontinue\n\t\trate = float(rst[0])\n\t\tc, g = None, None ",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tline = line.strip()\n\t\trst = re.findall(r'rate=([0-9.]+)',line)\n\t\tif not rst: \n\t\t\tcontinue\n\t\trate = float(rst[0])\n\t\tc, g = None, None \n\t\trst = re.findall(r'log2c=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tc = float(rst[0])\n\t\trst = re.findall(r'log2g=([0-9.-]+)',line)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\trst",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\trst = re.findall(r'rate=([0-9.]+)',line)\n\t\tif not rst: \n\t\t\tcontinue\n\t\trate = float(rst[0])\n\t\tc, g = None, None \n\t\trst = re.findall(r'log2c=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tc = float(rst[0])\n\t\trst = re.findall(r'log2g=([0-9.-]+)',line)\n\t\tif rst: ",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\trate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\trate = float(rst[0])\n\t\tc, g = None, None \n\t\trst = re.findall(r'log2c=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tc = float(rst[0])\n\t\trst = re.findall(r'log2g=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tg = float(rst[0])\n\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\trst",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\trst = re.findall(r'log2c=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tc = float(rst[0])\n\t\trst = re.findall(r'log2g=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tg = float(rst[0])\n\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs\nclass WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tc",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tc = float(rst[0])\n\t\trst = re.findall(r'log2g=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tg = float(rst[0])\n\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs\nclass WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass\nclass Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\trst",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\trst = re.findall(r'log2g=([0-9.-]+)',line)\n\t\tif rst: \n\t\t\tg = float(rst[0])\n\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs\nclass WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass\nclass Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):\n\t\tThread.__init__(self)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tg",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tg = float(rst[0])\n\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs\nclass WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass\nclass Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):\n\t\tThread.__init__(self)\n\t\tself.name = name\n\t\tself.job_queue = job_queue",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tresumed_jobs[(c,g)]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tresumed_jobs[(c,g)] = rate\n\treturn jobs, resumed_jobs\nclass WorkerStopToken:  # used to notify the worker to stop or if a worker is dead\n\tpass\nclass Worker(Thread):\n\tdef __init__(self,name,job_queue,result_queue,options):\n\t\tThread.__init__(self)\n\t\tself.name = name\n\t\tself.job_queue = job_queue\n\t\tself.result_queue = result_queue",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.name",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.name = name\n\t\tself.job_queue = job_queue\n\t\tself.result_queue = result_queue\n\t\tself.options = options\n\tdef run(self):\n\t\twhile True:\n\t\t\t(cexp,gexp) = self.job_queue.get()\n\t\t\tif cexp is WorkerStopToken:\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\t# print('worker {0} stop.'.format(self.name))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.job_queue",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.job_queue = job_queue\n\t\tself.result_queue = result_queue\n\t\tself.options = options\n\tdef run(self):\n\t\twhile True:\n\t\t\t(cexp,gexp) = self.job_queue.get()\n\t\t\tif cexp is WorkerStopToken:\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\t# print('worker {0} stop.'.format(self.name))\n\t\t\t\tbreak",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.result_queue",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.result_queue = result_queue\n\t\tself.options = options\n\tdef run(self):\n\t\twhile True:\n\t\t\t(cexp,gexp) = self.job_queue.get()\n\t\t\tif cexp is WorkerStopToken:\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\t# print('worker {0} stop.'.format(self.name))\n\t\t\t\tbreak\n\t\t\ttry:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.options",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.options = options\n\tdef run(self):\n\t\twhile True:\n\t\t\t(cexp,gexp) = self.job_queue.get()\n\t\t\tif cexp is WorkerStopToken:\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\t# print('worker {0} stop.'.format(self.name))\n\t\t\t\tbreak\n\t\t\ttry:\n\t\t\t\tc, g = None, None",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t(cexp,gexp)",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t(cexp,gexp) = self.job_queue.get()\n\t\t\tif cexp is WorkerStopToken:\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\t# print('worker {0} stop.'.format(self.name))\n\t\t\t\tbreak\n\t\t\ttry:\n\t\t\t\tc, g = None, None\n\t\t\t\tif cexp != None:\n\t\t\t\t\tc = 2.0**cexp\n\t\t\t\tif gexp != None:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tc",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tc = 2.0**cexp\n\t\t\t\tif gexp != None:\n\t\t\t\t\tg = 2.0**gexp\n\t\t\t\trate = self.run_one(c,g)\n\t\t\t\tif rate is None: raise RuntimeError('get no rate')\n\t\t\texcept:\n\t\t\t\t# we failed, let others do that and we just quit\n\t\t\t\ttraceback.print_exception(sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2])\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\tsys.stderr.write('worker {0} quit.\\n'.format(self.name))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tg",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tg = 2.0**gexp\n\t\t\t\trate = self.run_one(c,g)\n\t\t\t\tif rate is None: raise RuntimeError('get no rate')\n\t\t\texcept:\n\t\t\t\t# we failed, let others do that and we just quit\n\t\t\t\ttraceback.print_exception(sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2])\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\tsys.stderr.write('worker {0} quit.\\n'.format(self.name))\n\t\t\t\tbreak\n\t\t\telse:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\trate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\trate = self.run_one(c,g)\n\t\t\t\tif rate is None: raise RuntimeError('get no rate')\n\t\t\texcept:\n\t\t\t\t# we failed, let others do that and we just quit\n\t\t\t\ttraceback.print_exception(sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2])\n\t\t\t\tself.job_queue.put((cexp,gexp))\n\t\t\t\tsys.stderr.write('worker {0} quit.\\n'.format(self.name))\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tself.result_queue.put((self.name,cexp,gexp,rate))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tcmdline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tcmdline = '\"' + options.svmtrain_pathname + '\"'\n\t\tif options.grid_with_c: \n\t\t\tcmdline += ' -c {0} '.format(c)\n\t\tif options.grid_with_g: \n\t\t\tcmdline += ' -g {0} '.format(g)\n\t\tcmdline += ' -v {0} {1} {2} '.format\\\n\t\t\t(options.fold,options.pass_through_string,options.dataset_pathname)\n\t\treturn cmdline\nclass LocalWorker(Worker):\n\tdef run_one(self,c,g):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tcmdline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tcmdline = self.get_cmd(c,g)\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass SSHWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host\n\t\tself.cwd = os.getcwd()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass SSHWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host\n\t\tself.cwd = os.getcwd()\n\tdef run_one(self,c,g):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.host",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.host = host\n\t\tself.cwd = os.getcwd()\n\tdef run_one(self,c,g):\n\t\tcmdline = 'ssh -x -t -t {0} \"cd {1}; {2}\"'.format\\\n\t\t\t(self.host,self.cwd,self.get_cmd(c,g))\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass TelnetWorker(Worker):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.cwd",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.cwd = os.getcwd()\n\tdef run_one(self,c,g):\n\t\tcmdline = 'ssh -x -t -t {0} \"cd {1}; {2}\"'.format\\\n\t\t\t(self.host,self.cwd,self.get_cmd(c,g))\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass TelnetWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,username,password,options):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tcmdline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tcmdline = 'ssh -x -t -t {0} \"cd {1}; {2}\"'.format\\\n\t\t\t(self.host,self.cwd,self.get_cmd(c,g))\n\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass TelnetWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,username,password,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tresult = Popen(cmdline,shell=True,stdout=PIPE,stderr=PIPE,stdin=PIPE).stdout\n\t\tfor line in result.readlines():\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\nclass TelnetWorker(Worker):\n\tdef __init__(self,name,job_queue,result_queue,host,username,password,options):\n\t\tWorker.__init__(self,name,job_queue,result_queue,options)\n\t\tself.host = host\n\t\tself.username = username\n\t\tself.password = password\t\t",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.host",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.host = host\n\t\tself.username = username\n\t\tself.password = password\t\t\n\tdef run(self):\n\t\timport telnetlib\n\t\tself.tn = tn = telnetlib.Telnet(self.host)\n\t\ttn.read_until('login: ')\n\t\ttn.write(self.username + '\\n')\n\t\ttn.read_until('Password: ')\n\t\ttn.write(self.password + '\\n')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.username",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.username = username\n\t\tself.password = password\t\t\n\tdef run(self):\n\t\timport telnetlib\n\t\tself.tn = tn = telnetlib.Telnet(self.host)\n\t\ttn.read_until('login: ')\n\t\ttn.write(self.username + '\\n')\n\t\ttn.read_until('Password: ')\n\t\ttn.write(self.password + '\\n')\n\t\t# XXX: how to know whether login is successful?",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.password",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.password = password\t\t\n\tdef run(self):\n\t\timport telnetlib\n\t\tself.tn = tn = telnetlib.Telnet(self.host)\n\t\ttn.read_until('login: ')\n\t\ttn.write(self.username + '\\n')\n\t\ttn.read_until('Password: ')\n\t\ttn.write(self.password + '\\n')\n\t\t# XXX: how to know whether login is successful?\n\t\ttn.read_until(self.username)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tself.tn",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tself.tn = tn = telnetlib.Telnet(self.host)\n\t\ttn.read_until('login: ')\n\t\ttn.write(self.username + '\\n')\n\t\ttn.read_until('Password: ')\n\t\ttn.write(self.password + '\\n')\n\t\t# XXX: how to know whether login is successful?\n\t\ttn.read_until(self.username)\n\t\t# \n\t\tprint('login ok', self.host)\n\t\ttn.write('cd '+os.getcwd()+'\\n')",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tcmdline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tcmdline = self.get_cmd(c,g)\n\t\tresult = self.tn.write(cmdline+'\\n')\n\t\t(idx,matchm,output) = self.tn.expect(['Cross.*\\n'])\n\t\tfor line in output.split('\\n'):\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\ndef find_parameters(dataset_pathname, options=''):\n\tdef update_param(c,g,rate,best_c,best_g,best_rate,worker,resumed):\n\t\tif (rate > best_rate) or (rate==best_rate and g==best_g and c<best_c):\n\t\t\tbest_rate,best_c,best_g = rate,c,g",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tresult = self.tn.write(cmdline+'\\n')\n\t\t(idx,matchm,output) = self.tn.expect(['Cross.*\\n'])\n\t\tfor line in output.split('\\n'):\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\ndef find_parameters(dataset_pathname, options=''):\n\tdef update_param(c,g,rate,best_c,best_g,best_rate,worker,resumed):\n\t\tif (rate > best_rate) or (rate==best_rate and g==best_g and c<best_c):\n\t\t\tbest_rate,best_c,best_g = rate,c,g\n\t\tstdout_str = '[{0}] {1} {2} (best '.format\\",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t(idx,matchm,output)",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t(idx,matchm,output) = self.tn.expect(['Cross.*\\n'])\n\t\tfor line in output.split('\\n'):\n\t\t\tif str(line).find('Cross') != -1:\n\t\t\t\treturn float(line.split()[-1][0:-1])\ndef find_parameters(dataset_pathname, options=''):\n\tdef update_param(c,g,rate,best_c,best_g,best_rate,worker,resumed):\n\t\tif (rate > best_rate) or (rate==best_rate and g==best_g and c<best_c):\n\t\t\tbest_rate,best_c,best_g = rate,c,g\n\t\tstdout_str = '[{0}] {1} {2} (best '.format\\\n\t\t\t(worker,' '.join(str(x) for x in [c,g] if x is not None),rate)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tbest_rate,best_c,best_g",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tbest_rate,best_c,best_g = rate,c,g\n\t\tstdout_str = '[{0}] {1} {2} (best '.format\\\n\t\t\t(worker,' '.join(str(x) for x in [c,g] if x is not None),rate)\n\t\toutput_str = ''\n\t\tif c != None:\n\t\t\tstdout_str += 'c={0}, '.format(2.0**best_c)\n\t\t\toutput_str += 'log2c={0} '.format(c)\n\t\tif g != None:\n\t\t\tstdout_str += 'g={0}, '.format(2.0**best_g)\n\t\t\toutput_str += 'log2g={0} '.format(g)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tstdout_str",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tstdout_str = '[{0}] {1} {2} (best '.format\\\n\t\t\t(worker,' '.join(str(x) for x in [c,g] if x is not None),rate)\n\t\toutput_str = ''\n\t\tif c != None:\n\t\t\tstdout_str += 'c={0}, '.format(2.0**best_c)\n\t\t\toutput_str += 'log2c={0} '.format(c)\n\t\tif g != None:\n\t\t\tstdout_str += 'g={0}, '.format(2.0**best_g)\n\t\t\toutput_str += 'log2g={0} '.format(g)\n\t\tstdout_str += 'rate={0})'.format(best_rate)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\toutput_str",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\toutput_str = ''\n\t\tif c != None:\n\t\t\tstdout_str += 'c={0}, '.format(2.0**best_c)\n\t\t\toutput_str += 'log2c={0} '.format(c)\n\t\tif g != None:\n\t\t\tstdout_str += 'g={0}, '.format(2.0**best_g)\n\t\t\toutput_str += 'log2g={0} '.format(g)\n\t\tstdout_str += 'rate={0})'.format(best_rate)\n\t\tprint(stdout_str)\n\t\tif options.out_pathname and not resumed:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\toptions",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\toptions = GridOption(dataset_pathname, options);\n\tif options.gnuplot_pathname:\n\t\tgnuplot = Popen(options.gnuplot_pathname,stdin = PIPE,stdout=PIPE,stderr=PIPE).stdin\n\telse:\n\t\tgnuplot = None\n\t# put jobs in queue\n\tjobs,resumed_jobs = calculate_jobs(options)\n\tjob_queue = Queue(0)\n\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tgnuplot",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tgnuplot = Popen(options.gnuplot_pathname,stdin = PIPE,stdout=PIPE,stderr=PIPE).stdin\n\telse:\n\t\tgnuplot = None\n\t# put jobs in queue\n\tjobs,resumed_jobs = calculate_jobs(options)\n\tjob_queue = Queue(0)\n\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:\n\t\tresult_queue.put(('resumed',c,g,resumed_jobs[(c,g)]))\n\tfor line in jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tgnuplot",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tgnuplot = None\n\t# put jobs in queue\n\tjobs,resumed_jobs = calculate_jobs(options)\n\tjob_queue = Queue(0)\n\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:\n\t\tresult_queue.put(('resumed',c,g,resumed_jobs[(c,g)]))\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\tif (c,g) not in resumed_jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tjobs,resumed_jobs",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tjobs,resumed_jobs = calculate_jobs(options)\n\tjob_queue = Queue(0)\n\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:\n\t\tresult_queue.put(('resumed',c,g,resumed_jobs[(c,g)]))\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\tif (c,g) not in resumed_jobs:\n\t\t\t\tjob_queue.put((c,g))\n\t# hack the queue to become a stack --",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tjob_queue",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tjob_queue = Queue(0)\n\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:\n\t\tresult_queue.put(('resumed',c,g,resumed_jobs[(c,g)]))\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\tif (c,g) not in resumed_jobs:\n\t\t\t\tjob_queue.put((c,g))\n\t# hack the queue to become a stack --\n\t# this is important when some thread",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tresult_queue",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tresult_queue = Queue(0)\n\tfor (c,g) in resumed_jobs:\n\t\tresult_queue.put(('resumed',c,g,resumed_jobs[(c,g)]))\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\tif (c,g) not in resumed_jobs:\n\t\t\t\tjob_queue.put((c,g))\n\t# hack the queue to become a stack --\n\t# this is important when some thread\n\t# failed and re-put a job. It we still",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tjob_queue._put",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tjob_queue._put = job_queue.queue.appendleft\n\t# fire telnet workers\n\tif telnet_workers:\n\t\tnr_telnet_worker = len(telnet_workers)\n\t\tusername = getpass.getuser()\n\t\tpassword = getpass.getpass()\n\t\tfor host in telnet_workers:\n\t\t\tworker = TelnetWorker(host,job_queue,result_queue,\n\t\t\t\t\t host,username,password,options)\n\t\t\tworker.start()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tnr_telnet_worker",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tnr_telnet_worker = len(telnet_workers)\n\t\tusername = getpass.getuser()\n\t\tpassword = getpass.getpass()\n\t\tfor host in telnet_workers:\n\t\t\tworker = TelnetWorker(host,job_queue,result_queue,\n\t\t\t\t\t host,username,password,options)\n\t\t\tworker.start()\n\t# fire ssh workers\n\tif ssh_workers:\n\t\tfor host in ssh_workers:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tusername",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tusername = getpass.getuser()\n\t\tpassword = getpass.getpass()\n\t\tfor host in telnet_workers:\n\t\t\tworker = TelnetWorker(host,job_queue,result_queue,\n\t\t\t\t\t host,username,password,options)\n\t\t\tworker.start()\n\t# fire ssh workers\n\tif ssh_workers:\n\t\tfor host in ssh_workers:\n\t\t\tworker = SSHWorker(host,job_queue,result_queue,host,options)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tpassword",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tpassword = getpass.getpass()\n\t\tfor host in telnet_workers:\n\t\t\tworker = TelnetWorker(host,job_queue,result_queue,\n\t\t\t\t\t host,username,password,options)\n\t\t\tworker.start()\n\t# fire ssh workers\n\tif ssh_workers:\n\t\tfor host in ssh_workers:\n\t\t\tworker = SSHWorker(host,job_queue,result_queue,host,options)\n\t\t\tworker.start()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tworker",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tworker = TelnetWorker(host,job_queue,result_queue,\n\t\t\t\t\t host,username,password,options)\n\t\t\tworker.start()\n\t# fire ssh workers\n\tif ssh_workers:\n\t\tfor host in ssh_workers:\n\t\t\tworker = SSHWorker(host,job_queue,result_queue,host,options)\n\t\t\tworker.start()\n\t# fire local workers\n\tfor i in range(nr_local_worker):",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tworker",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tworker = SSHWorker(host,job_queue,result_queue,host,options)\n\t\t\tworker.start()\n\t# fire local workers\n\tfor i in range(nr_local_worker):\n\t\tworker = LocalWorker('local',job_queue,result_queue,options)\n\t\tworker.start()\n\t# gather results\n\tdone_jobs = {}\n\tif options.out_pathname:\n\t\tif options.resume_pathname:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tworker",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tworker = LocalWorker('local',job_queue,result_queue,options)\n\t\tworker.start()\n\t# gather results\n\tdone_jobs = {}\n\tif options.out_pathname:\n\t\tif options.resume_pathname:\n\t\t\tresult_file = open(options.out_pathname, 'a')\n\t\telse:\n\t\t\tresult_file = open(options.out_pathname, 'w')\n\tdb = []",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tdone_jobs",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tdone_jobs = {}\n\tif options.out_pathname:\n\t\tif options.resume_pathname:\n\t\t\tresult_file = open(options.out_pathname, 'a')\n\t\telse:\n\t\t\tresult_file = open(options.out_pathname, 'w')\n\tdb = []\n\tbest_rate = -1\n\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tresult_file = open(options.out_pathname, 'a')\n\t\telse:\n\t\t\tresult_file = open(options.out_pathname, 'w')\n\tdb = []\n\tbest_rate = -1\n\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:\n\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\tresult_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\tresult_file = open(options.out_pathname, 'w')\n\tdb = []\n\tbest_rate = -1\n\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:\n\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tdb",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tdb = []\n\tbest_rate = -1\n\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:\n\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:\n\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tbest_rate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tbest_rate = -1\n\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:\n\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:\n\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()\n\t\t\t\tdone_jobs[(c1,g1)] = rate1",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tbest_c,best_g",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tbest_c,best_g = None,None  \n\tfor (c,g) in resumed_jobs:\n\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:\n\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()\n\t\t\t\tdone_jobs[(c1,g1)] = rate1\n\t\t\t\tif (c1,g1) not in resumed_jobs:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\trate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\trate = resumed_jobs[(c,g)]\n\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:\n\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()\n\t\t\t\tdone_jobs[(c1,g1)] = rate1\n\t\t\t\tif (c1,g1) not in resumed_jobs:\n\t\t\t\t\tbest_c,best_g,best_rate = update_param(c1,g1,rate1,best_c,best_g,best_rate,worker,False)\n\t\t\tdb.append((c,g,done_jobs[(c,g)]))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tbest_c,best_g,best_rate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tbest_c,best_g,best_rate = update_param(c,g,rate,best_c,best_g,best_rate,'resumed',True)\n\tfor line in jobs:\n\t\tfor (c,g) in line:\n\t\t\twhile (c,g) not in done_jobs:\n\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()\n\t\t\t\tdone_jobs[(c1,g1)] = rate1\n\t\t\t\tif (c1,g1) not in resumed_jobs:\n\t\t\t\t\tbest_c,best_g,best_rate = update_param(c1,g1,rate1,best_c,best_g,best_rate,worker,False)\n\t\t\tdb.append((c,g,done_jobs[(c,g)]))\n\t\tif gnuplot and options.grid_with_c and options.grid_with_g:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t(worker,c1,g1,rate1)",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t(worker,c1,g1,rate1) = result_queue.get()\n\t\t\t\tdone_jobs[(c1,g1)] = rate1\n\t\t\t\tif (c1,g1) not in resumed_jobs:\n\t\t\t\t\tbest_c,best_g,best_rate = update_param(c1,g1,rate1,best_c,best_g,best_rate,worker,False)\n\t\t\tdb.append((c,g,done_jobs[(c,g)]))\n\t\tif gnuplot and options.grid_with_c and options.grid_with_g:\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options)\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options,True)\n\tif options.out_pathname:\n\t\tresult_file.close()",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdone_jobs[(c1,g1)]",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\tdone_jobs[(c1,g1)] = rate1\n\t\t\t\tif (c1,g1) not in resumed_jobs:\n\t\t\t\t\tbest_c,best_g,best_rate = update_param(c1,g1,rate1,best_c,best_g,best_rate,worker,False)\n\t\t\tdb.append((c,g,done_jobs[(c,g)]))\n\t\tif gnuplot and options.grid_with_c and options.grid_with_g:\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options)\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options,True)\n\tif options.out_pathname:\n\t\tresult_file.close()\n\tjob_queue.put((WorkerStopToken,None))",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tbest_c,best_g,best_rate",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\t\t\t\tbest_c,best_g,best_rate = update_param(c1,g1,rate1,best_c,best_g,best_rate,worker,False)\n\t\t\tdb.append((c,g,done_jobs[(c,g)]))\n\t\tif gnuplot and options.grid_with_c and options.grid_with_g:\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options)\n\t\t\tredraw(db,[best_c, best_g, best_rate],gnuplot,options,True)\n\tif options.out_pathname:\n\t\tresult_file.close()\n\tjob_queue.put((WorkerStopToken,None))\n\tbest_param, best_cg  = {}, []\n\tif best_c != None:",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tbest_param['c']",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tbest_param['c'] = 2.0**best_c\n\t\tbest_cg += [2.0**best_c]\n\tif best_g != None:\n\t\tbest_param['g'] = 2.0**best_g\n\t\tbest_cg += [2.0**best_g]\n\tprint('{0} {1}'.format(' '.join(map(str,best_cg)), best_rate))\n\treturn best_rate, best_param\nif __name__ == '__main__':\n\tdef exit_with_help():\n\t\tprint(\"\"\"\\",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\t\tbest_param['g']",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\t\tbest_param['g'] = 2.0**best_g\n\t\tbest_cg += [2.0**best_g]\n\tprint('{0} {1}'.format(' '.join(map(str,best_cg)), best_rate))\n\treturn best_rate, best_param\nif __name__ == '__main__':\n\tdef exit_with_help():\n\t\tprint(\"\"\"\\\nUsage: grid.py [grid_options] [svm_options] dataset\ngrid_options :\n-log2c {begin,end,step | \"null\"} : set the range of c (default -5,15,2)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\tdataset_pathname",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\tdataset_pathname = sys.argv[-1]\n\toptions = sys.argv[1:-1]\n\ttry:\n\t\tfind_parameters(dataset_pathname, options)\n\texcept (IOError,ValueError) as e:\n\t\tsys.stderr.write(str(e) + '\\n')\n\t\tsys.stderr.write('Try \"grid.py\" for more information.\\n')\n\t\tsys.exit(1)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "\toptions",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.grid",
        "description": "ext.libsvm.3.22.tools.grid",
        "peekOfCode": "\toptions = sys.argv[1:-1]\n\ttry:\n\t\tfind_parameters(dataset_pathname, options)\n\texcept (IOError,ValueError) as e:\n\t\tsys.stderr.write(str(e) + '\\n')\n\t\tsys.stderr.write('Try \"grid.py\" for more information.\\n')\n\t\tsys.exit(1)",
        "detail": "ext.libsvm.3.22.tools.grid",
        "documentation": {}
    },
    {
        "label": "exit_with_help",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "def exit_with_help(argv):\n\tprint(\"\"\"\\\nUsage: {0} [options] dataset subset_size [output1] [output2]\nThis script randomly selects a subset of the dataset.\noptions:\n-s method : method of selection (default 0)\n     0 -- stratified selection (classification only)\n     1 -- random selection\noutput1 : the subset (optional)\noutput2 : rest of the data (optional)",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "process_options",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "def process_options(argv):\n\targc = len(argv)\n\tif argc < 3:\n\t\texit_with_help(argv)\n\t# default method is stratified selection\n\tmethod = 0  \n\tsubset_file = sys.stdout\n\trest_file = None\n\ti = 1\n\twhile i < argc:",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "random_selection",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "def random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))\ndef stratified_selection(dataset, subset_size):\n\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]\n\tl = len(labels)\n\tremaining = subset_size",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "stratified_selection",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "def stratified_selection(dataset, subset_size):\n\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]\n\tl = len(labels)\n\tremaining = subset_size\n\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "def main(argv=sys.argv):\n\tdataset, subset_size, method, subset_file, rest_file = process_options(argv)\n\t#uncomment the following line to fix the random seed \n\t#random.seed(0)\n\tselected_lines = []\n\tif method == 0:\n\t\tselected_lines = stratified_selection(dataset, subset_size)\n\telif method == 1:\n\t\tselected_lines = random_selection(dataset, subset_size)\n\t#select instances based on selected_lines",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\txrange",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\txrange = range\ndef exit_with_help(argv):\n\tprint(\"\"\"\\\nUsage: {0} [options] dataset subset_size [output1] [output2]\nThis script randomly selects a subset of the dataset.\noptions:\n-s method : method of selection (default 0)\n     0 -- stratified selection (classification only)\n     1 -- random selection\noutput1 : the subset (optional)",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\targc",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\targc = len(argv)\n\tif argc < 3:\n\t\texit_with_help(argv)\n\t# default method is stratified selection\n\tmethod = 0  \n\tsubset_file = sys.stdout\n\trest_file = None\n\ti = 1\n\twhile i < argc:\n\t\tif argv[i][0] != \"-\":",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tmethod",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tmethod = 0  \n\tsubset_file = sys.stdout\n\trest_file = None\n\ti = 1\n\twhile i < argc:\n\t\tif argv[i][0] != \"-\":\n\t\t\tbreak\n\t\tif argv[i] == \"-s\":\n\t\t\ti = i + 1\n\t\t\tmethod = int(argv[i])",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tsubset_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tsubset_file = sys.stdout\n\trest_file = None\n\ti = 1\n\twhile i < argc:\n\t\tif argv[i][0] != \"-\":\n\t\t\tbreak\n\t\tif argv[i] == \"-s\":\n\t\t\ti = i + 1\n\t\t\tmethod = int(argv[i])\n\t\t\tif method not in [0,1]:",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\trest_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\trest_file = None\n\ti = 1\n\twhile i < argc:\n\t\tif argv[i][0] != \"-\":\n\t\t\tbreak\n\t\tif argv[i] == \"-s\":\n\t\t\ti = i + 1\n\t\t\tmethod = int(argv[i])\n\t\t\tif method not in [0,1]:\n\t\t\t\tprint(\"Unknown selection method {0}\".format(method))",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\ti = 1\n\twhile i < argc:\n\t\tif argv[i][0] != \"-\":\n\t\t\tbreak\n\t\tif argv[i] == \"-s\":\n\t\t\ti = i + 1\n\t\t\tmethod = int(argv[i])\n\t\t\tif method not in [0,1]:\n\t\t\t\tprint(\"Unknown selection method {0}\".format(method))\n\t\t\t\texit_with_help(argv)",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\t\ti = i + 1\n\t\t\tmethod = int(argv[i])\n\t\t\tif method not in [0,1]:\n\t\t\t\tprint(\"Unknown selection method {0}\".format(method))\n\t\t\t\texit_with_help(argv)\n\t\ti = i + 1\n\tdataset = argv[i]\n\tsubset_size = int(argv[i+1])\n\tif i+2 < argc:\n\t\tsubset_file = open(argv[i+2],'w')",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\t\tmethod",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\t\tmethod = int(argv[i])\n\t\t\tif method not in [0,1]:\n\t\t\t\tprint(\"Unknown selection method {0}\".format(method))\n\t\t\t\texit_with_help(argv)\n\t\ti = i + 1\n\tdataset = argv[i]\n\tsubset_size = int(argv[i+1])\n\tif i+2 < argc:\n\t\tsubset_file = open(argv[i+2],'w')\n\tif i+3 < argc:",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\ti = i + 1\n\tdataset = argv[i]\n\tsubset_size = int(argv[i+1])\n\tif i+2 < argc:\n\t\tsubset_file = open(argv[i+2],'w')\n\tif i+3 < argc:\n\t\trest_file = open(argv[i+3],'w')\n\treturn dataset, subset_size, method, subset_file, rest_file\ndef random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tdataset",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tdataset = argv[i]\n\tsubset_size = int(argv[i+1])\n\tif i+2 < argc:\n\t\tsubset_file = open(argv[i+2],'w')\n\tif i+3 < argc:\n\t\trest_file = open(argv[i+3],'w')\n\treturn dataset, subset_size, method, subset_file, rest_file\ndef random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tsubset_size",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tsubset_size = int(argv[i+1])\n\tif i+2 < argc:\n\t\tsubset_file = open(argv[i+2],'w')\n\tif i+3 < argc:\n\t\trest_file = open(argv[i+3],'w')\n\treturn dataset, subset_size, method, subset_file, rest_file\ndef random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))\ndef stratified_selection(dataset, subset_size):",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tsubset_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tsubset_file = open(argv[i+2],'w')\n\tif i+3 < argc:\n\t\trest_file = open(argv[i+3],'w')\n\treturn dataset, subset_size, method, subset_file, rest_file\ndef random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))\ndef stratified_selection(dataset, subset_size):\n\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\trest_file",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\trest_file = open(argv[i+3],'w')\n\treturn dataset, subset_size, method, subset_file, rest_file\ndef random_selection(dataset, subset_size):\n\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))\ndef stratified_selection(dataset, subset_size):\n\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tl",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tl = sum(1 for line in open(dataset,'r'))\n\treturn sorted(random.sample(xrange(l), subset_size))\ndef stratified_selection(dataset, subset_size):\n\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]\n\tl = len(labels)\n\tremaining = subset_size\n\tret = []",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tlabels",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tlabels = [line.split(None,1)[0] for line in open(dataset)]\n\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]\n\tl = len(labels)\n\tremaining = subset_size\n\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected\n\tfor label in sorted(label_linenums, key=lambda x: len(label_linenums[x])):",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tlabel_linenums",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tlabel_linenums = defaultdict(list)\n\tfor i, label in enumerate(labels):\n\t\tlabel_linenums[label] += [i]\n\tl = len(labels)\n\tremaining = subset_size\n\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected\n\tfor label in sorted(label_linenums, key=lambda x: len(label_linenums[x])):\n\t\tlinenums = label_linenums[label]",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tl",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tl = len(labels)\n\tremaining = subset_size\n\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected\n\tfor label in sorted(label_linenums, key=lambda x: len(label_linenums[x])):\n\t\tlinenums = label_linenums[label]\n\t\tlabel_size = len(linenums) \n\t\t# at least one instance per class\n\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tremaining",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tremaining = subset_size\n\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected\n\tfor label in sorted(label_linenums, key=lambda x: len(label_linenums[x])):\n\t\tlinenums = label_linenums[label]\n\t\tlabel_size = len(linenums) \n\t\t# at least one instance per class\n\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))\n\t\tif s == 0:",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tret",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tret = []\n\t# classes with fewer data are sampled first; otherwise\n\t# some rare classes may not be selected\n\tfor label in sorted(label_linenums, key=lambda x: len(label_linenums[x])):\n\t\tlinenums = label_linenums[label]\n\t\tlabel_size = len(linenums) \n\t\t# at least one instance per class\n\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))\n\t\tif s == 0:\n\t\t\tsys.stderr.write('''\\",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tlinenums",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tlinenums = label_linenums[label]\n\t\tlabel_size = len(linenums) \n\t\t# at least one instance per class\n\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))\n\t\tif s == 0:\n\t\t\tsys.stderr.write('''\\\nError: failed to have at least one instance per class\n    1. You may have regression data.\n    2. Your classification data is unbalanced or too small.\nPlease use -s 1.",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tlabel_size",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tlabel_size = len(linenums) \n\t\t# at least one instance per class\n\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))\n\t\tif s == 0:\n\t\t\tsys.stderr.write('''\\\nError: failed to have at least one instance per class\n    1. You may have regression data.\n    2. Your classification data is unbalanced or too small.\nPlease use -s 1.\n''')",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\ts",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\ts = int(min(remaining, max(1, math.ceil(label_size*(float(subset_size)/l)))))\n\t\tif s == 0:\n\t\t\tsys.stderr.write('''\\\nError: failed to have at least one instance per class\n    1. You may have regression data.\n    2. Your classification data is unbalanced or too small.\nPlease use -s 1.\n''')\n\t\t\tsys.exit(-1)\n\t\tremaining -= s",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tselected_lines",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tselected_lines = []\n\tif method == 0:\n\t\tselected_lines = stratified_selection(dataset, subset_size)\n\telif method == 1:\n\t\tselected_lines = random_selection(dataset, subset_size)\n\t#select instances based on selected_lines\n\tdataset = open(dataset,'r')\n\tprev_selected_linenum = -1\n\tfor i in xrange(len(selected_lines)):\n\t\tfor cnt in xrange(selected_lines[i]-prev_selected_linenum-1):",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tselected_lines",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tselected_lines = stratified_selection(dataset, subset_size)\n\telif method == 1:\n\t\tselected_lines = random_selection(dataset, subset_size)\n\t#select instances based on selected_lines\n\tdataset = open(dataset,'r')\n\tprev_selected_linenum = -1\n\tfor i in xrange(len(selected_lines)):\n\t\tfor cnt in xrange(selected_lines[i]-prev_selected_linenum-1):\n\t\t\tline = dataset.readline()\n\t\t\tif rest_file: ",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tselected_lines",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tselected_lines = random_selection(dataset, subset_size)\n\t#select instances based on selected_lines\n\tdataset = open(dataset,'r')\n\tprev_selected_linenum = -1\n\tfor i in xrange(len(selected_lines)):\n\t\tfor cnt in xrange(selected_lines[i]-prev_selected_linenum-1):\n\t\t\tline = dataset.readline()\n\t\t\tif rest_file: \n\t\t\t\trest_file.write(line)\n\t\tsubset_file.write(dataset.readline())",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tdataset",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tdataset = open(dataset,'r')\n\tprev_selected_linenum = -1\n\tfor i in xrange(len(selected_lines)):\n\t\tfor cnt in xrange(selected_lines[i]-prev_selected_linenum-1):\n\t\t\tline = dataset.readline()\n\t\t\tif rest_file: \n\t\t\t\trest_file.write(line)\n\t\tsubset_file.write(dataset.readline())\n\t\tprev_selected_linenum = selected_lines[i]\n\tsubset_file.close()",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\tprev_selected_linenum",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\tprev_selected_linenum = -1\n\tfor i in xrange(len(selected_lines)):\n\t\tfor cnt in xrange(selected_lines[i]-prev_selected_linenum-1):\n\t\t\tline = dataset.readline()\n\t\t\tif rest_file: \n\t\t\t\trest_file.write(line)\n\t\tsubset_file.write(dataset.readline())\n\t\tprev_selected_linenum = selected_lines[i]\n\tsubset_file.close()\n\tif rest_file:",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\t\tline = dataset.readline()\n\t\t\tif rest_file: \n\t\t\t\trest_file.write(line)\n\t\tsubset_file.write(dataset.readline())\n\t\tprev_selected_linenum = selected_lines[i]\n\tsubset_file.close()\n\tif rest_file:\n\t\tfor line in dataset: \n\t\t\trest_file.write(line)\n\t\trest_file.close()",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "\t\tprev_selected_linenum",
        "kind": 5,
        "importPath": "ext.libsvm.3.22.tools.subset",
        "description": "ext.libsvm.3.22.tools.subset",
        "peekOfCode": "\t\tprev_selected_linenum = selected_lines[i]\n\tsubset_file.close()\n\tif rest_file:\n\t\tfor line in dataset: \n\t\t\trest_file.write(line)\n\t\trest_file.close()\n\tdataset.close()\nif __name__ == '__main__':\n\tmain(sys.argv)",
        "detail": "ext.libsvm.3.22.tools.subset",
        "documentation": {}
    },
    {
        "label": "bb",
        "kind": 2,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "peekOfCode": "def bb(x):\n    dim = x.get_n()\n    f = sum([x.get_coord(i)**2 for i in xrange(dim)])    \n    x.set_bb_output(0, f )\n    return 1 # 1: success 0: failed evaluation\nx0 = [0.71,0.51,0.51]\nlb = [-1,-1,-1]\nub=[]\nparams = ['BB_OUTPUT_TYPE OBJ','MAX_BB_EVAL 100','UPPER_BOUND * 1'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "documentation": {}
    },
    {
        "label": "x0",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "peekOfCode": "x0 = [0.71,0.51,0.51]\nlb = [-1,-1,-1]\nub=[]\nparams = ['BB_OUTPUT_TYPE OBJ','MAX_BB_EVAL 100','UPPER_BOUND * 1'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "documentation": {}
    },
    {
        "label": "lb",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "peekOfCode": "lb = [-1,-1,-1]\nub=[]\nparams = ['BB_OUTPUT_TYPE OBJ','MAX_BB_EVAL 100','UPPER_BOUND * 1'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "peekOfCode": "params = ['BB_OUTPUT_TYPE OBJ','MAX_BB_EVAL 100','UPPER_BOUND * 1'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest",
        "documentation": {}
    },
    {
        "label": "bb",
        "kind": 2,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "peekOfCode": "def bb(x):\n    try:\n        dim = x.get_n()\n        f = x.get_coord(4)\n        x.set_bb_output(0,f)\n        g1 = sum([(x.get_coord(i)-1)**2 for i in xrange(dim)])-25\n        x.set_bb_output(1,g1)\n        g2 = 25-sum([(x.get_coord(i)+1)**2 for i in xrange(dim)])\n        x.set_bb_output(2,g2)\n        # test = 1* (1/0) # ---> uncomment to trigger an exception",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "documentation": {}
    },
    {
        "label": "ub",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "peekOfCode": "ub = [ 5,6,7,10,10]\nparams = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100','X0 * 0' , 'LOWER_BOUND * -6' ] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,[],[],ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "peekOfCode": "params = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100','X0 * 0' , 'LOWER_BOUND * -6' ] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,[],[],ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_2",
        "documentation": {}
    },
    {
        "label": "bb",
        "kind": 2,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "peekOfCode": "def bb(x,bb_out):\n    try:\n        dim = x.get_n()\n        f = x.get_coord(4)\n        g1 = sum([(x.get_coord(i)-1)**2 for i in xrange(dim)])-25\n        g2 = 25-sum([(x.get_coord(i)+1)**2 for i in xrange(dim)])\n        bb_out.put([f,g1,g2])\n    except:\n        print \"Unexpected error:\", sys.exc_info()[0]\n\tsys.exit(0)        ",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "documentation": {}
    },
    {
        "label": "x0",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "peekOfCode": "x0 = [0,0,0.71,0.51,0.51]\nlb = [-6,-6,-6,-6,-6]\nub = [ 5,6,7,10,10]\nparams = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100' , 'BB_MAX_BLOCK_SIZE 8','DISPLAY_STATS BBE BLK_EVA OBJ'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "documentation": {}
    },
    {
        "label": "lb",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "peekOfCode": "lb = [-6,-6,-6,-6,-6]\nub = [ 5,6,7,10,10]\nparams = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100' , 'BB_MAX_BLOCK_SIZE 8','DISPLAY_STATS BBE BLK_EVA OBJ'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "documentation": {}
    },
    {
        "label": "ub",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "peekOfCode": "ub = [ 5,6,7,10,10]\nparams = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100' , 'BB_MAX_BLOCK_SIZE 8','DISPLAY_STATS BBE BLK_EVA OBJ'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "peekOfCode": "params = ['BB_OUTPUT_TYPE OBJ PB EB','MAX_BB_EVAL 100' , 'BB_MAX_BLOCK_SIZE 8','DISPLAY_STATS BBE BLK_EVA OBJ'] \n[ x_return , f_return , h_return, nb_evals , nb_iters ,  stopflag ] = PyNomad.optimize(bb,x0,lb,ub,params)\nprint ('\\n NOMAD outputs \\n X_sol={} \\n F_sol={} \\n H_sol={} \\n NB_evals={} \\n NB_iters={} \\n'.format(x_return,f_return,h_return,nb_evals,nb_iters))",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.runTest_BlockEval",
        "documentation": {}
    },
    {
        "label": "compile_args",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "peekOfCode": "compile_args = ['-w']\nlink_args = []\n# Look for librairies in Nomad distribution\nif sys.platform.startswith('linux'):\n    link_args.append('-Wl,-rpath,'+str(os.environ.get('NOMAD_HOME'))+'/lib')\n# Prevent error message when changing the location of libnomad.so (OSX)\nif sys.platform == 'darwin':\n\tlink_args.append('-headerpad_max_install_names')\nsetup(\n\text_modules = cythonize(Extension(",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "documentation": {}
    },
    {
        "label": "link_args",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "peekOfCode": "link_args = []\n# Look for librairies in Nomad distribution\nif sys.platform.startswith('linux'):\n    link_args.append('-Wl,-rpath,'+str(os.environ.get('NOMAD_HOME'))+'/lib')\n# Prevent error message when changing the location of libnomad.so (OSX)\nif sys.platform == 'darwin':\n\tlink_args.append('-headerpad_max_install_names')\nsetup(\n\text_modules = cythonize(Extension(\n           \"PyNomad\",                                # the extesion name",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "documentation": {}
    },
    {
        "label": "\text_modules",
        "kind": 5,
        "importPath": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "description": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "peekOfCode": "\text_modules = cythonize(Extension(\n           \"PyNomad\",                                # the extesion name\n           sources=[\"PyNomad.pyx\", \"nomadCySimpleInterface.cpp\"], # the Cython source and\n\t       include_dirs = [str(os.environ.get('NOMAD_HOME'))+'/src',str(os.environ.get('NOMAD_HOME'))+'/ext/sgtelib/src', np.get_include()],\n           extra_compile_args=compile_args,\n           extra_link_args=link_args,\n           language = 'c++',\n           libraries = ['nomad'],\n           library_dirs = [ str(os.environ.get('NOMAD_HOME')) + '/lib'],))\n)",
        "detail": "ext.nomad.3.8.1.examples.interfaces.pyNomad_Beta.setup_PyNomad",
        "documentation": {}
    },
    {
        "label": "datasets",
        "kind": 5,
        "importPath": "median.collections.create_samples",
        "description": "median.collections.create_samples",
        "peekOfCode": "datasets = [\"Mutagenicity-Correct.xml\", \"AIDS.xml\", \"Letter.xml\"]\nsample_script = \"../../data/collections/sample.py\"\nsize_ratios = [.1, .2, .3, .4, .5, .6, .7, .8, .9, 1]\nsample_ids = range(5)\nfor dataset in datasets:\n    for size_ratio in size_ratios:\n        for sample_id in sample_ids:\n            sample_name = dataset.split('.')[0] + \"-\" + str(int(size_ratio * 100)) + \"-\" + str(sample_id) + \".xml\"\n            command = \"python \" + sample_script + \" \" + dataset + \" \" + sample_name + \" --balanced --size_ratio \" + str(size_ratio)\n            call(command, shell=True)",
        "detail": "median.collections.create_samples",
        "documentation": {}
    },
    {
        "label": "sample_script",
        "kind": 5,
        "importPath": "median.collections.create_samples",
        "description": "median.collections.create_samples",
        "peekOfCode": "sample_script = \"../../data/collections/sample.py\"\nsize_ratios = [.1, .2, .3, .4, .5, .6, .7, .8, .9, 1]\nsample_ids = range(5)\nfor dataset in datasets:\n    for size_ratio in size_ratios:\n        for sample_id in sample_ids:\n            sample_name = dataset.split('.')[0] + \"-\" + str(int(size_ratio * 100)) + \"-\" + str(sample_id) + \".xml\"\n            command = \"python \" + sample_script + \" \" + dataset + \" \" + sample_name + \" --balanced --size_ratio \" + str(size_ratio)\n            call(command, shell=True)",
        "detail": "median.collections.create_samples",
        "documentation": {}
    },
    {
        "label": "size_ratios",
        "kind": 5,
        "importPath": "median.collections.create_samples",
        "description": "median.collections.create_samples",
        "peekOfCode": "size_ratios = [.1, .2, .3, .4, .5, .6, .7, .8, .9, 1]\nsample_ids = range(5)\nfor dataset in datasets:\n    for size_ratio in size_ratios:\n        for sample_id in sample_ids:\n            sample_name = dataset.split('.')[0] + \"-\" + str(int(size_ratio * 100)) + \"-\" + str(sample_id) + \".xml\"\n            command = \"python \" + sample_script + \" \" + dataset + \" \" + sample_name + \" --balanced --size_ratio \" + str(size_ratio)\n            call(command, shell=True)",
        "detail": "median.collections.create_samples",
        "documentation": {}
    },
    {
        "label": "sample_ids",
        "kind": 5,
        "importPath": "median.collections.create_samples",
        "description": "median.collections.create_samples",
        "peekOfCode": "sample_ids = range(5)\nfor dataset in datasets:\n    for size_ratio in size_ratios:\n        for sample_id in sample_ids:\n            sample_name = dataset.split('.')[0] + \"-\" + str(int(size_ratio * 100)) + \"-\" + str(sample_id) + \".xml\"\n            command = \"python \" + sample_script + \" \" + dataset + \" \" + sample_name + \" --balanced --size_ratio \" + str(size_ratio)\n            call(command, shell=True)",
        "detail": "median.collections.create_samples",
        "documentation": {}
    },
    {
        "label": "aggregate_results",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def aggregate_results(csv_file):\n    rs = pd.read_csv(csv_file)\n    rs.itrs = rs.itrs.apply(lambda l: [int(x) for x in l.split(\";\")])\n    grouped = rs.groupby([\"percent\", \"init_type\", \"num_inits\", \"algo\"], as_index=False)\n    concat_lists = lambda ll: [x for l in ll for x in l if x > 0] \n    as_list = lambda ll: [x for x in ll]\n    ratio_greater = lambda l, t: float(len([x for x in l if x > t])) / float(len(l))\n    agg_rs = grouped.agg({\"time\": np.mean, \"time_init\": np.mean, \"time_converged\": np.mean, \"sod\": np.mean, \"sod_init\": np.mean, \"sod_converged\": np.mean, \"itrs\": concat_lists, \"state\": as_list})\n    agg_rs[\"itrs_max\"] = agg_rs.itrs.apply(lambda l: max(l) if len(l) > 0 else 0)\n    agg_rs[\"itrs_min\"] = agg_rs.itrs.apply(lambda l: min(l) if len(l) > 0 else None)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "compute_rs_vs_percent",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def compute_rs_vs_percent(agg_rs):\n    row_rs = pd.DataFrame([10 * i for i in range(1, 11)], columns = [\"percent\"])\n    algos = [\"BRANCH_FAST\", \"REFINE\", \"IPFP\"]\n    init_types = [\"MAX\", \"MIN\", \"MEAN\", \"MEDOID\", \"RANDOM\"]\n    nums_inits = [2 ** i for i in range(6)]\n    cols = ['time', 'time_init', 'time_converged', 'sod', 'sod_init', 'sod_converged', 'itrs', 'state', 'itrs_max', 'itrs_min', 'itrs_mean', 'itrs_lower_quartile', 'itrs_median', 'itrs_upper_quartile', 'ratio_initialized', 'ratio_converged', 'ratio_refined']\n    for algo in algos:\n        for init_type in init_types:\n            for num_inits in nums_inits:\n                if num_inits > 1 and init_type != \"RANDOM\":",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "compute_rs_vs_num_inits",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def compute_rs_vs_num_inits(agg_rs):\n    row_rs = pd.DataFrame([2 ** i for i in range(6)], columns = [\"num_inits\"])\n    algos = [\"BRANCH_FAST\", \"REFINE\", \"IPFP\"]\n    percents = [10 * i for i in range(1, 11)]\n    cols = ['percent', 'time', 'time_init', 'time_converged', 'sod', 'sod_init', 'sod_converged', 'itrs', 'state', 'itrs_max', 'itrs_min', 'itrs_mean', 'itrs_lower_quartile', 'itrs_median', 'itrs_upper_quartile', 'ratio_initialized', 'ratio_converged', 'ratio_refined']\n    for algo in algos:\n        for percent in percents:\n            prefix = algo + \"_RANDOM_P\" + str(percent) + \"_\"\n            for col in cols:\n                row_rs[prefix + col] = agg_rs[(agg_rs.algo == algo) & (agg_rs.init_type == \"RANDOM\") & (agg_rs.percent == percent)][col].reset_index()[col]",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_init_plots",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta):\n    tikz = open(\"../img/effect_num_inits.tex\", \"w\")\n    tikz.write(\"%!TEX root = ../main.tex\\n\")\n    tikz.write(\"\\\\begin{tikzpicture}\\n\")\n    tikz.write(\"\\\\begin{groupplot}[group style={group name=groupplot, group size=3 by 2, horizontal sep=1.1cm, vertical sep=1.5cm},\\n\")\n    tikz.write(\"width=.36\\linewidth,\\n\")\n    tikz.write(\"height=.25\\linewidth,\\n\")\n    tikz.write(\"legend columns=3,\\n\")\n    tikz.write(\"legend cell align=left,\\n\")\n    tikz.write(\"legend style={align=left, draw=none, column sep=.5ex},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_config_plots",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta):\n    tikz = open(\"../img/effect_configs.tex\", \"w\")\n    tikz.write(\"%!TEX root = ../main.tex\\n\")\n    tikz.write(\"\\\\begin{tikzpicture}\\n\")\n    tikz.write(\"\\\\begin{groupplot}[group style={group name=groupplot, group size=3 by 2, horizontal sep=1.1cm, vertical sep=1.5cm},\\n\")\n    tikz.write(\"width=.36\\linewidth,\\n\")\n    tikz.write(\"height=.25\\linewidth,\\n\")\n    tikz.write(\"legend columns=3,\\n\")\n    tikz.write(\"legend cell align=left,\\n\")\n    tikz.write(\"legend style={align=left, draw=none, column sep=.5ex},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_boxplots_inits_vs_itrs",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_boxplots_inits_vs_itrs(rs_vs_num_inits, tikz, title):\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"boxplot/draw direction=y,\\n\")\n    tikz.write(\"xtick={2,6,10,14,18,22},\\n\")\n    tikz.write(\"xticklabels={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xlabel={initial solutions},\\n\")\n    tikz.write(\"ylabel={iterations},\\n\")\n    tikz.write(\"ylabel style={yshift=-.1cm},\\n\")\n    tikz.write(\"xlabel style={yshift=.1cm},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_paretoplots_sod_vs_time",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_paretoplots_sod_vs_time(rs_vs_percent, tikz, title, legend = False):\n    index = 8\n    marks = {\"MAX\" : \"mark=o\", \"MIN\" : \"mark=square\", \"MEAN\" : \"mark=triangle\", \"MEDOID\" : \"mark=diamond\", \"RANDOM\" : \"mark=pentagon\", \"MAXconv\" : \"mark=+\", \"MINconv\" : \"mark=x\", \"MEANconv\" : \"mark=-\", \"MEDOIDconv\" : \"mark=|\", \"RANDOMconv\" : \"mark=star\"}\n    colors = {\"BRANCH_FAST\" : \"draw=BRANCHFAST\", \"REFINE\" : \"draw=REFINE\", \"IPFP\" : \"draw=IPFP\"} \n    num_inits = {\"MAX\" : 1, \"MIN\" : 1, \"MEAN\" : 1, \"MEDOID\" : 1, \"RANDOMBRANCH_FAST\" : 8, \"RANDOMREFINE\" : 2, \"RANDOMIPFP\" : 2}\n    macros = {\"BRANCH_FAST\" : \"BRANCHFAST\", \"REFINE\" : \"REFINE\", \"IPFP\" : \"IPFP\"}\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xlabel={mean runtime in \\\\si{\\\\second}},\\n\")\n    tikz.write(\"ylabel={mean \\SOD at termination},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_lineplots_max_itrs_vs_percent",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_lineplots_max_itrs_vs_percent(rs_vs_percent, tikz, title, legend = False):\n    marks = {\"MAX\" : \"mark=o\", \"MIN\" : \"mark=square\", \"MEAN\" : \"mark=triangle\", \"MEDOID\" : \"mark=diamond\", \"RANDOM\" : \"mark=pentagon\", \"MAXconv\" : \"mark=+\", \"MINconv\" : \"mark=x\", \"MEANconv\" : \"mark=-\", \"MEDOIDconv\" : \"mark=|\", \"RANDOMconv\" : \"mark=star\"}\n    colors = {\"BRANCH_FAST\" : \"draw=BRANCHFAST\", \"REFINE\" : \"draw=REFINE\", \"IPFP\" : \"draw=IPFP\"} \n    num_inits = {\"MAX\" : 1, \"MIN\" : 1, \"MEAN\" : 1, \"MEDOID\" : 1, \"RANDOMBRANCH_FAST\" : 8, \"RANDOMREFINE\" : 2, \"RANDOMIPFP\" : 2}\n    macros = {\"BRANCH_FAST\" : \"BRANCHFAST\", \"REFINE\" : \"REFINE\", \"IPFP\" : \"IPFP\"}\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xtick={10,20,30,40,50,60,70,80,90},\\n\")\n    tikz.write(\"xticklabels={10,20,30,40,50,60,70,80,90},\\n\")\n    tikz.write(\"xlabel={\\\\si{\\\\percent} of graphs in collection},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_lineplots_inits_vs_sod",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_lineplots_inits_vs_sod(rs_vs_num_inits, tikz, title, legend = False):\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xtick={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xticklabels={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xlabel={initial solutions},\\n\")\n    tikz.write(\"ylabel={mean \\SOD at termination},\\n\")\n    tikz.write(\"ylabel style={yshift=-.1cm},\\n\")\n    tikz.write(\"xlabel style={yshift=.1cm},\\n\")\n    tikz.write(\"xmode=log,\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_lineplots_inits_vs_max_itrs",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_lineplots_inits_vs_max_itrs(rs_vs_num_inits, tikz, title, legend = False):\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xtick={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xticklabels={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xlabel={initial solutions},\\n\")\n    tikz.write(\"ylabel={max \\# iterations},\\n\")\n    tikz.write(\"ylabel style={yshift=-.1cm},\\n\")\n    tikz.write(\"xlabel style={yshift=.1cm},\\n\")\n    tikz.write(\"xmode=log,\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_lineplots_inits_vs_time",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_lineplots_inits_vs_time(rs_vs_num_inits, tikz, title):\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xtick={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xticklabels={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xlabel={initial solutions},\\n\")\n    tikz.write(\"ylabel={\\SOD},\\n\")\n    tikz.write(\"ylabel style={yshift=-.1cm},\\n\")\n    tikz.write(\"xlabel style={yshift=.1cm},\\n\")\n    tikz.write(\"xmode=log,\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "create_barplots_inits_vs_state",
        "kind": 2,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "def create_barplots_inits_vs_state(rs_vs_num_inits, tikz, title):\n    tikz.write(\"\\\\nextgroupplot[\\n\")\n    tikz.write(\"title=\" + title + \",\\n\")\n    tikz.write(\"xtick={2,6,10,14,18,22},\\n\")\n    tikz.write(\"xticklabels={1,2,4,8,16,32},\\n\")\n    tikz.write(\"xlabel={initial solutions},\\n\")\n    tikz.write(\"ylabel={termination state in \\\\si{\\\\percent}},\\n\")\n    tikz.write(\"ylabel style={yshift=-.1cm},\\n\")\n    tikz.write(\"ymin=0,\\n\")\n    tikz.write(\"xlabel style={yshift=.1cm},\\n\")",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "agg_rs_letter",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "agg_rs_letter = aggregate_results(\"Letter_RESULTS.csv\")\nagg_rs_aids = aggregate_results(\"AIDS_RESULTS.csv\")\nagg_rs_muta = aggregate_results(\"Mutagenicity_RESULTS.csv\")\nrs_vs_num_inits_letter = compute_rs_vs_num_inits(agg_rs_letter)\nrs_vs_num_inits_aids = compute_rs_vs_num_inits(agg_rs_aids)\nrs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "agg_rs_aids",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "agg_rs_aids = aggregate_results(\"AIDS_RESULTS.csv\")\nagg_rs_muta = aggregate_results(\"Mutagenicity_RESULTS.csv\")\nrs_vs_num_inits_letter = compute_rs_vs_num_inits(agg_rs_letter)\nrs_vs_num_inits_aids = compute_rs_vs_num_inits(agg_rs_aids)\nrs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "agg_rs_muta",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "agg_rs_muta = aggregate_results(\"Mutagenicity_RESULTS.csv\")\nrs_vs_num_inits_letter = compute_rs_vs_num_inits(agg_rs_letter)\nrs_vs_num_inits_aids = compute_rs_vs_num_inits(agg_rs_aids)\nrs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_num_inits_letter",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_num_inits_letter = compute_rs_vs_num_inits(agg_rs_letter)\nrs_vs_num_inits_aids = compute_rs_vs_num_inits(agg_rs_aids)\nrs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_num_inits_aids",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_num_inits_aids = compute_rs_vs_num_inits(agg_rs_aids)\nrs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_num_inits_muta",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_num_inits_muta = compute_rs_vs_num_inits(agg_rs_muta)\ncreate_init_plots(rs_vs_num_inits_letter, rs_vs_num_inits_aids, rs_vs_num_inits_muta)\nrs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_percent_letter",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_percent_letter = compute_rs_vs_percent(agg_rs_letter)\nrs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_percent_aids",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_percent_aids = compute_rs_vs_percent(agg_rs_aids)\nrs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "rs_vs_percent_muta",
        "kind": 5,
        "importPath": "median.process_results",
        "description": "median.process_results",
        "peekOfCode": "rs_vs_percent_muta = compute_rs_vs_percent(agg_rs_muta)\ncreate_config_plots(rs_vs_percent_letter, rs_vs_percent_aids, rs_vs_percent_muta)",
        "detail": "median.process_results",
        "documentation": {}
    },
    {
        "label": "Method",
        "kind": 6,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "class Method:\n    def __init__(self, name, ub, t, ub_diag):\n        self.consider_lb = True\n        self.name = name[0]\n        if self.name == \"KREFINE\":\n            self.name = \"3REFINE\"\n        elif self.name == \"REFINE\":\n            self.name = \"2REFINE\"\n        self.num_randpost_loops = name[1][2:-2].split(\",\")[2]\n        self.randpost_penalty = name[1][2:-2].split(\",\")[3]",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "parse_method_name",
        "kind": 2,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "def parse_method_name(method_name):\n    method_name_list = method_name.split(\",\", 1)\n    if (len(method_name_list) == 1):\n        method_name_list.append(\"\")\n    return method_name_list\ndef read_results(result_file_name):\n    methods = []\n    with open(result_file_name, \"r\") as result_file:  \n        csv_reader = csv.reader(result_file, delimiter=\";\")\n        next(csv_reader, NONE)",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "read_results",
        "kind": 2,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "def read_results(result_file_name):\n    methods = []\n    with open(result_file_name, \"r\") as result_file:  \n        csv_reader = csv.reader(result_file, delimiter=\";\")\n        next(csv_reader, NONE)\n        for row in csv_reader:\n            methods.append(Method(parse_method_name(row[0]), row[2], row[3], row[4]))\n    return methods\ndef find_best_randpost_penalties(methods):\n    method_names = set()",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "find_best_randpost_penalties",
        "kind": 2,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "def find_best_randpost_penalties(methods):\n    method_names = set()\n    randpost_penalties = set()\n    for method in methods:\n        method_names.add(method.name)\n        randpost_penalties.add(method.randpost_penalty)\n    ub_sums = {method_name : { randpost_penalty : 0.0 for randpost_penalty in randpost_penalties } for method_name in method_names}\n    for method in methods:\n        if method.num_randpost_loops != \"0\":\n            ub_sums[method.name][method.randpost_penalty] = ub_sums[method.name][method.randpost_penalty] + method.ub",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "write_best_randpost_penalties",
        "kind": 2,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "def write_best_randpost_penalties(randpost_penalties_file_name, best_randpost_penalties):\n    randpost_penalties_file = open(randpost_penalties_file_name, \"w\")\n    col = 1\n    num_cols = len(best_randpost_penalties)\n    for method_name in best_randpost_penalties:\n        randpost_penalties_file.write(method_name)\n        if col < num_cols:\n            randpost_penalties_file.write(\",\")\n        else:\n            randpost_penalties_file.write(\"\\n\")",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "write_pgf_file",
        "kind": 2,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "def write_pgf_file(pgf_file_name, best_randpost_penalties, methods):\n    method_ids = {num_randpost_loops : {method_name : -1 for method_name in best_randpost_penalties} for num_randpost_loops in [\"0\", \"1\", \"3\", \"7\"]}\n    method_id = 0\n    for method in methods:\n        if (method.num_randpost_loops == \"0\") or (method.randpost_penalty == best_randpost_penalties[method.name]):\n            method_ids[method.num_randpost_loops][method.name] = method_id\n        method_id = method_id + 1\n    pgf_file = open(pgf_file_name, \"w\")\n    pgf_file.write(\"L\")\n    for method_name in best_randpost_penalties:",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Determines best RANDPOST penalties and outputs .\")\nparser.add_argument(\"result_file_name\", help=\"name of input result file\")\nparser.add_argument(\"pgf_file_name\", help=\"name of output file to be used for PGF plots\")\nparser.add_argument(\"randpost_penalties_file_name\", help=\"name of output file listing best RANDPOST penalties\")\nargs = parser.parse_args()\nmethods = read_results(args.result_file_name)\nbest_randpost_penalties = find_best_randpost_penalties(methods)\nwrite_best_randpost_penalties(args.randpost_penalties_file_name, best_randpost_penalties)\nwrite_pgf_file(args.pgf_file_name, best_randpost_penalties, methods)",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "args = parser.parse_args()\nmethods = read_results(args.result_file_name)\nbest_randpost_penalties = find_best_randpost_penalties(methods)\nwrite_best_randpost_penalties(args.randpost_penalties_file_name, best_randpost_penalties)\nwrite_pgf_file(args.pgf_file_name, best_randpost_penalties, methods)",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "methods",
        "kind": 5,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "methods = read_results(args.result_file_name)\nbest_randpost_penalties = find_best_randpost_penalties(methods)\nwrite_best_randpost_penalties(args.randpost_penalties_file_name, best_randpost_penalties)\nwrite_pgf_file(args.pgf_file_name, best_randpost_penalties, methods)",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "best_randpost_penalties",
        "kind": 5,
        "importPath": "tests.prl2019.process_results",
        "description": "tests.prl2019.process_results",
        "peekOfCode": "best_randpost_penalties = find_best_randpost_penalties(methods)\nwrite_best_randpost_penalties(args.randpost_penalties_file_name, best_randpost_penalties)\nwrite_pgf_file(args.pgf_file_name, best_randpost_penalties, methods)",
        "detail": "tests.prl2019.process_results",
        "documentation": {}
    },
    {
        "label": "Method",
        "kind": 6,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "class Method:\n    def __init__(self, name, lb, ub, t, coeff_lb, coeff_ub):\n        self.consider_lb = True\n        self.name = name[0]\n        if self.name == \"SUBGGRAPH\":\n            self.name = \"SUBGRAPH\"\n        self.config = name[1]\n        self.lb = float(\"{0:.2f}\".format(Decimal(lb)))\n        self.ub = float(\"{0:.2f}\".format(Decimal(ub)))\n        self.t = float(\"{:.6f}\".format(Decimal(t)))",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "AggregatedScores",
        "kind": 6,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "class AggregatedScores:\n    def __init__(self, method_names, scores_lb, scores_ub, has_tightest_lb, is_fastest_lb, has_best_coeff_lb, has_tightest_ub, is_fastest_ub, has_best_coeff_ub):\n        self.method_names = method_names\n        self.scores_lb = scores_lb\n        self.scores_ub = scores_ub\n        self.has_tightest_lb = has_tightest_lb\n        self.is_fastest_lb = is_fastest_lb\n        self.has_best_coeff_lb = has_best_coeff_lb\n        self.has_tightest_ub = has_tightest_ub\n        self.is_fastest_ub = is_fastest_ub",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "computes_no_lb",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def computes_no_lb(method_name, method_config=\"\"):\n    if method_name == \"BP\":\n        return True\n    elif method_name == \"SUBGRAPH\":\n        return True\n    elif method_name == \"WALKS\":\n        return True\n    elif method_name == \"RINGOPT\":\n        return True\n    elif method_name == \"RINGMS\":",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "computes_no_ub",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def computes_no_ub(method_name):\n    if method_name == \"HED\":\n        return True\n    elif method_name == \"BRANCHCOMPACT\":\n        return True\n    elif method_name == \"PARTITION\":\n        return True\n    elif method_name == \"HYBRID\":\n        return True\n    else:",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "is_ls_based",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def is_ls_based(method):\n    if method.name == \"REFINE\":\n        return True\n    elif method.name == \"KREFINE\":\n        return True\n    elif method.name == \"BPBEAM\":\n        return True\n    elif method.name == \"IBPBEAM\":\n        return True\n    elif method.name == \"IPFP\":",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "is_lsape_based",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def is_lsape_based(method):\n    if method.name == \"BP\":\n        return True\n    elif method.name == \"BRANCH\":\n        return True\n    elif method.name == \"BRANCHFAST\":\n        return True\n    elif method.name == \"BRANCHUNI\":\n        return True\n    elif method.name == \"STAR\":",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "uses_randpost",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def uses_randpost(method):\n    if is_ls_based(method):\n        return (int(method.config[2:-2].split(\",\")[2]) > 0)\n    else:\n        return False\ndef uses_multi_start(method):\n    if is_ls_based(method):\n        return (int(method.config[2:-2].split(\",\")[0]) > 1)\n    else:\n        return False",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "uses_multi_start",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def uses_multi_start(method):\n    if is_ls_based(method):\n        return (int(method.config[2:-2].split(\",\")[0]) > 1)\n    else:\n        return False\ndef uses_multi_sol(method):\n    if is_lsape_based(method):\n        return (int(method.config[2:-2].split(\",\")[0]) > 1)\n    else:\n        return False",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "uses_multi_sol",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def uses_multi_sol(method):\n    if is_lsape_based(method):\n        return (int(method.config[2:-2].split(\",\")[0]) > 1)\n    else:\n        return False\ndef uses_centralities(method):\n    if is_lsape_based(method):\n        return (float(method.config[2:-2].split(\",\")[1]) > 0)\n    else:\n        return False",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "uses_centralities",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def uses_centralities(method):\n    if is_lsape_based(method):\n        return (float(method.config[2:-2].split(\",\")[1]) > 0)\n    else:\n        return False\nclass Method:\n    def __init__(self, name, lb, ub, t, coeff_lb, coeff_ub):\n        self.consider_lb = True\n        self.name = name[0]\n        if self.name == \"SUBGGRAPH\":",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "parse_method_name",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def parse_method_name(method_name):\n    method_name_list = method_name.split(\",\", 1)\n    if (len(method_name_list) == 1):\n        method_name_list.append(\"\")\n    return method_name_list\ndef dfs(methods, is_discarded_edge, parent_id, child_id, seen):\n    if seen[child_id]:\n        return\n    for edge in methods[child_id].get_adj_list():\n        is_discarded_edge[parent_id][edge[0]] = True;",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def dfs(methods, is_discarded_edge, parent_id, child_id, seen):\n    if seen[child_id]:\n        return\n    for edge in methods[child_id].get_adj_list():\n        is_discarded_edge[parent_id][edge[0]] = True;\n        dfs(methods, is_discarded_edge, parent_id, edge[0], seen)\n    seen[child_id] = True\ndef read_results_from_csv_files(dataset, args):\n    methods = []\n    result_file_names = []",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "read_results_from_csv_files",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def read_results_from_csv_files(dataset, args):\n    methods = []\n    result_file_names = []\n    prefix = os.path.join(\"results\", dataset) + \"__\"\n    if not args.no_lsape:\n        result_file_names.append(prefix + \"lsape_based_methods.csv\")\n    if not args.no_ls:\n        result_file_names.append(prefix + \"ls_based_methods.csv\")\n    if not args.no_lp:\n        result_file_names.append(prefix + \"lp_based_methods.csv\")",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "build_dependency_graph",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def build_dependency_graph(methods, consider_lb):\n    # set consider_lb for all methods\n    for method in methods:\n        method.consider_lb = consider_lb\n    # construct dominance graph\n    num_methods = len(methods)\n    adj_list = [[] for method_id in range(0,num_methods)]\n    for id_1 in range(0, num_methods):\n        method_1 = methods[id_1]\n        new_adj_list = []",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "infix",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def infix(args):\n    the_infix = \"\"\n    if args.no_lsape:\n        the_infix = the_infix + \"_no-lsape\"\n    if args.no_ls:\n        the_infix = the_infix + \"_no-ls\"\n    if args.no_lp:\n        the_infix = the_infix + \"_no-lp\"\n    if args.no_misc:\n        the_infix = the_infix + \"_no-misc\"",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "create_latex_tables",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def create_latex_tables(args, datasets, aggregated_scores, lsape_based_method_names, lp_based_method_names, ls_based_method_names, misc_method_names, lsape_ext_names, ls_ext_names):\n    sum_best_coeff_lb = {}\n    table_ub_file_name = os.path.join(args.table_dir, \"results_UB.tex\")\n    table_ub = open(table_ub_file_name, \"w\")\n    table_ub.write(\"%!TEX root = ../root.tex\\n\")\n    table_ub.write(\"\\\\begin{tabular}{@{}lcS[table-format=1.2]cS[table-format=1.2]cS[table-format=1.2]cS[table-format=1.2]cS[table-format=1.2]cS[table-format=1.2]@{}}\\n\")\n    table_ub.write(\"\\\\toprule\\n\")\n    table_ub.write(\"heuristic & \\multicolumn{2}{c}{\\\\letter} & \\multicolumn{2}{c}{\\\\mutagenicity} & \\multicolumn{2}{c}{\\\\aids} & \\multicolumn{2}{c}{\\\\protein} & \\multicolumn{2}{c}{\\\\fingerprint} & \\multicolumn{2}{c}{\\\\grec} \\\\\\\\\\n\")\n    table_ub.write(\"\\midrule\\n\")\n    table_ub.write(\"& {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} & {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} & {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} & {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} & {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} & {$\\chi_\\UB$} & {$\\widehat{s_\\UB}$} \\\\\\\\\\n\")",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "create_pareto_data",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def create_pareto_data(args, dataset, methods, consider_lb, method_names):\n    selected_method_names = [method_name for method_name in method_names if not computes_no_ub(method_name)]\n    infix = \"UB\"\n    bound_column_name = \"avg_ub\"\n    runtime_column_name = \"avg_runtime\"\n    if consider_lb:\n        selected_method_names = [method_name for method_name in method_names if not computes_no_lb(method_name)]\n        infix = \"LB\"\n        bound_column_name = \"avg_lb\"\n    max_score_methods = {method_name : None for method_name in selected_method_names}",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "create_barplots",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def create_barplots(args, datasets, aggregated_scores, method_names, lsape_ext_names, ls_ext_names):\n    lb_method_names = [method_name for method_name in method_names if not computes_no_lb(method_name)]\n    ub_method_names = [method_name for method_name in method_names if not computes_no_ub(method_name)]\n    # sum scores and chi for lower bounds\n    scores_lb = {method_name : 0 for method_name in lb_method_names}\n    has_tightest_lb = {method_name : 0 for method_name in lb_method_names}\n    is_fastest_lb = {method_name : 0 for method_name in lb_method_names}\n    has_best_coeff_lb = {method_name : 0 for method_name in lb_method_names}\n    for method_name in lb_method_names:\n        for dataset in datasets:",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "write_barplot",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def write_barplot(barplot_file_name, ylabel, ymax, width, method_bars, lsape_ext_bars = [], ls_ext_bars = []):\n    num_bars = len(method_bars + lsape_ext_bars + ls_ext_bars)\n    xtick = \",\".join(str(i * 0.5) for i in range(1, num_bars + 1))\n    xticklabels = \",\".join(\"\\\\\" + kv[0] for kv in (method_bars + lsape_ext_bars + ls_ext_bars))\n    barplot_file = open(barplot_file_name, \"w\")\n    barplot_file.write(\"%!TEX root = ../root.tex\\n\")\n    barplot_file.write(\"\\\\begin{tikzpicture}\\n\")\n    barplot_file.write(\"\\\\begin{axis}[\\n\")\n    barplot_file.write(\"height = 0.4\\linewidth,\\n\")\n    barplot_file.write(\"width = \" + str(width) + \"\\linewidth,\\n\")",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "aggregate_scores",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def aggregate_scores(methods, method_names, method_ext_names):\n    scores_lb = {method_name : 0.0 for method_name in method_names}\n    scores_ub = {method_name : 0.0 for method_name in method_ext_names}\n    has_tightest_lb = {method_name : False for method_name in method_names}\n    is_fastest_lb = {method_name : False for method_name in method_names}\n    has_best_coeff_lb = {method_name : False for method_name in method_names}\n    has_tightest_ub = {method_name : False for method_name in method_ext_names}\n    is_fastest_ub = {method_name : False for method_name in method_ext_names}\n    has_best_coeff_ub = {method_name : False for method_name in method_ext_names}\n    sum_scores_ub_lsape = 0.0",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "create_coeff_vs_dist_table",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def create_coeff_vs_dist_table(args, dataset, methods, consider_lb):\n    table_file_name = os.path.join(args.data_dir, dataset) + infix(args)\n    if consider_lb:\n        table_file_name = table_file_name + \"_LB.csv\"\n    else:\n        table_file_name = table_file_name + \"_UB.csv\"\n    table_file = open(table_file_name, \"w\")\n    if consider_lb:\n        table_file.write(\"avg_lb,coeff_lb\\n\")\n    else:",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "create_tikz_graph",
        "kind": 2,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "def create_tikz_graph(args, dataset, methods, consider_lb):\n    tikz_file_name = os.path.join(args.tikz_dir, dataset) + infix(args)\n    if consider_lb:\n        tikz_file_name = tikz_file_name + \"_LB.tex\"\n    else:\n        tikz_file_name = tikz_file_name + \"_UB.tex\"\n    # construct tikz file\n    tikz_file = open(tikz_file_name, \"w\")\n    tikz_file.write(\"%!TEX root = ../root.tex\\n\")\n    tikz_file.write(\"\\\\begin{tikzpicture}[rounded corners,every label/.style={align=center}]\\n\")",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Generates TikZ dominance graph from CSV file.\")\nparser.add_argument(\"tikz_dir\", help=\"name of output directory for TikZ files\")\nparser.add_argument(\"table_dir\", help=\"name of output directory for LaTeX tables\")\nparser.add_argument(\"data_dir\", help=\"name of output directory for csv tables\")\nparser.add_argument(\"--no_lsape\", help=\"do not consider LSAPE based methods\", action=\"store_true\")\nparser.add_argument(\"--no_ls\", help=\"do not consider local search based methods\", action=\"store_true\")\nparser.add_argument(\"--no_lp\", help=\"do not consider LP based methods\", action=\"store_true\")\nparser.add_argument(\"---no_misc\", help=\"do not consider miscellaneous methods\", action=\"store_true\")\nargs = parser.parse_args()\ndatasets = [\"Letter_HIGH\", \"Mutagenicity\", \"AIDS\", \"Protein\", \"Fingerprint\", \"GREC\"]",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "args = parser.parse_args()\ndatasets = [\"Letter_HIGH\", \"Mutagenicity\", \"AIDS\", \"Protein\", \"Fingerprint\", \"GREC\"]\naggregated_scores = {}\nlsape_based_method_names = [\"NODE\", \"BP\", \"BRANCH\", \"BRANCHFAST\", \"BRANCHUNI\", \"STAR\", \"SUBGRAPH\", \"WALKS\", \"RINGOPT\", \"RINGMS\", \"RINGMLSVM\", \"RINGMLDNN\", \"PREDICTSVM\", \"PREDICTDNN\"]\nlp_based_method_names = [\"FONE\", \"FTWO\", \"COMPACTMIP\", \"JUSTICEIP\"]\nls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "datasets",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "datasets = [\"Letter_HIGH\", \"Mutagenicity\", \"AIDS\", \"Protein\", \"Fingerprint\", \"GREC\"]\naggregated_scores = {}\nlsape_based_method_names = [\"NODE\", \"BP\", \"BRANCH\", \"BRANCHFAST\", \"BRANCHUNI\", \"STAR\", \"SUBGRAPH\", \"WALKS\", \"RINGOPT\", \"RINGMS\", \"RINGMLSVM\", \"RINGMLDNN\", \"PREDICTSVM\", \"PREDICTDNN\"]\nlp_based_method_names = [\"FONE\", \"FTWO\", \"COMPACTMIP\", \"JUSTICEIP\"]\nls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "aggregated_scores",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "aggregated_scores = {}\nlsape_based_method_names = [\"NODE\", \"BP\", \"BRANCH\", \"BRANCHFAST\", \"BRANCHUNI\", \"STAR\", \"SUBGRAPH\", \"WALKS\", \"RINGOPT\", \"RINGMS\", \"RINGMLSVM\", \"RINGMLDNN\", \"PREDICTSVM\", \"PREDICTDNN\"]\nlp_based_method_names = [\"FONE\", \"FTWO\", \"COMPACTMIP\", \"JUSTICEIP\"]\nls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "lsape_based_method_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "lsape_based_method_names = [\"NODE\", \"BP\", \"BRANCH\", \"BRANCHFAST\", \"BRANCHUNI\", \"STAR\", \"SUBGRAPH\", \"WALKS\", \"RINGOPT\", \"RINGMS\", \"RINGMLSVM\", \"RINGMLDNN\", \"PREDICTSVM\", \"PREDICTDNN\"]\nlp_based_method_names = [\"FONE\", \"FTWO\", \"COMPACTMIP\", \"JUSTICEIP\"]\nls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "lp_based_method_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "lp_based_method_names = [\"FONE\", \"FTWO\", \"COMPACTMIP\", \"JUSTICEIP\"]\nls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "ls_based_method_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "ls_based_method_names = [\"REFINE\", \"KREFINE\", \"BPBEAM\", \"IBPBEAM\", \"IPFP\"]\nmisc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "misc_method_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "misc_method_names = [\"HED\", \"BRANCHTIGHT\", \"SA\", \"BRANCHCOMPACT\", \"PARTITION\", \"HYBRID\"]\nlsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)\n        create_pareto_data(args, dataset, methods, consider_lb, method_names)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "lsape_ext_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "lsape_ext_names = [\"MULTISOL\", \"CENTRALITIES\"]\nls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)\n        create_pareto_data(args, dataset, methods, consider_lb, method_names)\n        create_tikz_graph(args, dataset, methods, consider_lb)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "ls_ext_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "ls_ext_names = [\"MULTISTART\", \"RANDPOST\"]\nmethod_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)\n        create_pareto_data(args, dataset, methods, consider_lb, method_names)\n        create_tikz_graph(args, dataset, methods, consider_lb)\n        create_coeff_vs_dist_table(args, dataset, methods, consider_lb)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "method_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "method_names = lsape_based_method_names + lp_based_method_names + ls_based_method_names + misc_method_names\nmethod_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)\n        create_pareto_data(args, dataset, methods, consider_lb, method_names)\n        create_tikz_graph(args, dataset, methods, consider_lb)\n        create_coeff_vs_dist_table(args, dataset, methods, consider_lb)\n    aggregated_scores[dataset] = aggregate_scores(methods, method_names, method_ext_names)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "method_ext_names",
        "kind": 5,
        "importPath": "tests.vldbj2019.process_results",
        "description": "tests.vldbj2019.process_results",
        "peekOfCode": "method_ext_names = method_names + lsape_ext_names + ls_ext_names\nfor dataset in datasets:\n    methods = read_results_from_csv_files(dataset, args)\n    for consider_lb in [True, False]:\n        methods = build_dependency_graph(methods, consider_lb)\n        create_pareto_data(args, dataset, methods, consider_lb, method_names)\n        create_tikz_graph(args, dataset, methods, consider_lb)\n        create_coeff_vs_dist_table(args, dataset, methods, consider_lb)\n    aggregated_scores[dataset] = aggregate_scores(methods, method_names, method_ext_names)\ncreate_latex_tables(args, datasets, aggregated_scores, lsape_based_method_names, lp_based_method_names, ls_based_method_names, misc_method_names, lsape_ext_names, ls_ext_names)",
        "detail": "tests.vldbj2019.process_results",
        "documentation": {}
    },
    {
        "label": "append_ged_env_hpp",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def append_ged_env_hpp(identifier, node_id_type, node_label_type, edge_label_type):\n\tappend = \"\"\n\tappend = append + \"\\n\";\n\tappend = append + \"#ifdef \" + identifier.upper() + \"_GEDLIB_SHARED\\n\"\n\tappend = append + \"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\"\n\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "append_cmake_lists",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def append_cmake_lists(identifier):\n    append = \"\"\n    append = append + \"\\n\"\n    append = append + \"add_library(\" + identifier.lower() + \"gedlib SHARED env/ged_env.\" + identifier.lower() + \".cpp)\\n\"\n    append = append + \"set_target_properties(\" + identifier.lower() + \"gedlib PROPERTIES SUFFIX \\\".so\\\")\\n\"\n    append = append + \"target_link_libraries(\" + identifier.lower() + \"gedlib nomad doublefann svm)\\n\"\n    append = append + \"if(APPLE)\\n\"\n    append = append + \"  add_custom_command(TARGET \" + identifier.lower() + \"gedlib POST_BUILD COMMAND install_name_tool -change libnomad.so ${NOMAD_HOME}/lib/libnomad.so ${LIBRARY_OUTPUT_PATH}/lib\" + identifier.lower() + \"gedlib.so)\\n\"\n    append = append + \"  add_custom_command(TARGET \" + identifier.lower() + \"gedlib POST_BUILD COMMAND install_name_tool -change libdoublefann.2.dylib ${FANN_HOME}/lib/libdoublefann.2.dylib ${LIBRARY_OUTPUT_PATH}/lib\" + identifier.lower() + \"gedlib.so)\\n\"\n    append = append + \"  add_custom_command(TARGET \" + identifier.lower() + \"gedlib POST_BUILD COMMAND install_name_tool -change libsvm.so ${LIBSVM_HOME}/libsvm.so ${LIBRARY_OUTPUT_PATH}/lib\" + identifier.lower() + \"gedlib.so)\\n\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "create_template_instantiation",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def create_template_instantiation(identifier, node_id_type, node_label_type, edge_label_type):\n\twith open(\"src/env/ged_env.\" + identifier.lower() + \".cpp\", \"w\") as f:\n\t\tf.write(\"/*!\\n\")\n\t\tf.write(\" * @file ged_env.\" + identifier.lower() + \".cpp\\n\")\n\t\tf.write(\" * @brief ged::GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \"> template instantiation.\\n\")\n\t\tf.write(\" */\\n\")\n\t\tf.write(\"\\n\")\n\t\tf.write(\"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\")\n\t\tf.write(\"#define SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\")\n\t\tf.write(\"\\n\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "parse_custom_types",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def parse_custom_types(custom_types):\n\tif len(custom_types.split(\",\")) != 4:\n\t\traise Exception(\"Invalid argument \\\"\" + args.lib + \"\\\" for option lib. Usage: python install.py [--lib gxl|<indentifier-different-from-'gxl'>,<node-ID-type>,<node-label-type>,<edge-label-type>] [...]\")\n\treturn custom_types.split(\",\")\ndef create_directories():\n\tprint(\"\\n***** Create directories for shared libraries, executables and output. *****\")\n\tcommands = \"mkdir -p lib; \"\n\tcommands = commands + \"mkdir -p tests/tkde2019/bin; mkdir -p tests/tkde2019/output; \"\n\tcommands = commands + \"mkdir -p tests/vldbj2019/bin; mkdir -p tests/vldbj2019/ini; mkdir -p tests/vldbj2019/results; \"\n\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "create_directories",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def create_directories():\n\tprint(\"\\n***** Create directories for shared libraries, executables and output. *****\")\n\tcommands = \"mkdir -p lib; \"\n\tcommands = commands + \"mkdir -p tests/tkde2019/bin; mkdir -p tests/tkde2019/output; \"\n\tcommands = commands + \"mkdir -p tests/vldbj2019/bin; mkdir -p tests/vldbj2019/ini; mkdir -p tests/vldbj2019/results; \"\n\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"\n\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "build_external_libraries",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:\n\t\tprint(\"\\n***** Install external libraries. *****\")\n\t\tcommands = \"cd ext/fann.2.2.0; mkdir -p build; cd build; rm -rf *; cmake -DCMAKE_INSTALL_PREFIX=.. ..; make install; cd ..; rm -rf build\"\n\t\tcall(commands, shell=True) \n\t\tcommands = \"cd ext/nomad.3.8.1; mkdir -p lib; mkdir -p bin; cd src; make clean; make all; make clean; rm -rf ../bin\"\n\t\tcall(commands, shell=True)\n\t\tcommands = \"cd ext/libsvm.3.22; make lib; rm -f svm.o\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "determine_gurobi_dylib",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def determine_gurobi_dylib(gurobi_root):\n\tif not os.path.isdir(gurobi_root):\n\t\traise Exception(\"Invalid argument \\\"\" + gurobi_root + \"\\\" for option gurobi: not a directory. Usage: python install.py [--gurobi <path-to-root-directory-of-Gurobi>] [...]\")\n\treturn \"gurobi\" + gurobi_root[gurobi_root.index(\"gurobi\") + 6 : gurobi_root.index(\"gurobi\") + 8]\ndef determine_gurobi_statlib(gurobi_root):\n\tstatlib = \"gurobi_c++\"\n\tif platform.system() == \"Linux\":\n\t\tinfo = {item.split(\":\\t\")[0] : item.split(\":\\t\")[1] for item in subprocess.check_output(\"lsb_release -a\", shell=True).decode(\"utf-8\").split(\"\\n\")[:-1]}\n\t\tif info[\"Distributor ID\"] == \"Ubuntu\" and (info[\"Release\"] == \"16.04\" or info[\"Release\"] == \"18.04\"):\n\t\t\tstatlib = \"gurobi_g++5.2\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "determine_gurobi_statlib",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def determine_gurobi_statlib(gurobi_root):\n\tstatlib = \"gurobi_c++\"\n\tif platform.system() == \"Linux\":\n\t\tinfo = {item.split(\":\\t\")[0] : item.split(\":\\t\")[1] for item in subprocess.check_output(\"lsb_release -a\", shell=True).decode(\"utf-8\").split(\"\\n\")[:-1]}\n\t\tif info[\"Distributor ID\"] == \"Ubuntu\" and (info[\"Release\"] == \"16.04\" or info[\"Release\"] == \"18.04\"):\n\t\t\tstatlib = \"gurobi_g++5.2\"\n\treturn statlib\t\ndef build_gedlib(args):\n\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "build_gedlib",
        "kind": 2,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "def build_gedlib(args):\n\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":\n\t\tidentifier, node_id_type, node_label_type, edge_label_type = parse_custom_types(args.lib)\n\t\tif identifier.lower() == \"gxl\":\n\t\t\traise Exception(\"Invalid argument \\\"\" + args.lib + \"\\\" for option lib. Usage: python install.py [--lib gxl|<indentifier-different-from-'gxl'>,<node-ID-type>,<node-label-type>,<edge-label-type>] [...]\")\n\t\tprint(\"\\n***** Modify sources for building user-defined shared library. *****\")\n\t\tcreate_template_instantiation(identifier, node_id_type, node_label_type, edge_label_type)\n\t\tappend_ged_env_hpp(identifier, node_id_type, node_label_type, edge_label_type)\n\t\tappend_cmake_lists(identifier)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = \"\"\n\tappend = append + \"\\n\";\n\tappend = append + \"#ifdef \" + identifier.upper() + \"_GEDLIB_SHARED\\n\"\n\tappend = append + \"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\"\n\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"\\n\";\n\tappend = append + \"#ifdef \" + identifier.upper() + \"_GEDLIB_SHARED\\n\"\n\tappend = append + \"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\"\n\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"#ifdef \" + identifier.upper() + \"_GEDLIB_SHARED\\n\"\n\tappend = append + \"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\"\n\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"#ifndef SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_\\n\"\n\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"extern template class GEDEnv<\" + node_id_type + \", \" + node_label_type + \", \" + edge_label_type + \">;\\n\"\n\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"#endif /* SRC_ENV_GED_ENV_\" + identifier.upper() + \"_CPP_ */\\n\"\n\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):\n\t\t\t\tline = line + append",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tappend",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tappend = append + \"#endif /*\" + identifier.upper() + \"_GEDLIB_SHARED */\\n\"\n\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):\n\t\t\t\tline = line + append\n\t\t\tif delete_line <= 0:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tdelete_line",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tdelete_line = 0\n\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):\n\t\t\t\tline = line + append\n\t\t\tif delete_line <= 0:\n\t\t\t\ttemp.write(line)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\ttemp",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\ttemp = open(\"temp\", \"wb\")\n\twith open(\"src/env/ged_env.hpp\", \"r\") as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"#ifdef \") and not line.startswith(\"#ifdef GXL_GEDLIB_SHARED\"):\n\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):\n\t\t\t\tline = line + append\n\t\t\tif delete_line <= 0:\n\t\t\t\ttemp.write(line)\n\t\t\tdelete_line = delete_line - 1",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdelete_line",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\t\tdelete_line = 6\n\t\t\tif line.startswith(\"#endif /* GXL_GEDLIB_SHARED */\"):\n\t\t\t\tline = line + append\n\t\t\tif delete_line <= 0:\n\t\t\t\ttemp.write(line)\n\t\t\tdelete_line = delete_line - 1\n\ttemp.close()\n\tshutil.move(\"temp\", \"src/env/ged_env.hpp\")\ndef append_cmake_lists(identifier):\n    append = \"\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\t\tline = line + append\n\t\t\tif delete_line <= 0:\n\t\t\t\ttemp.write(line)\n\t\t\tdelete_line = delete_line - 1\n\ttemp.close()\n\tshutil.move(\"temp\", \"src/env/ged_env.hpp\")\ndef append_cmake_lists(identifier):\n    append = \"\"\n    append = append + \"\\n\"\n    append = append + \"add_library(\" + identifier.lower() + \"gedlib SHARED env/ged_env.\" + identifier.lower() + \".cpp)\\n\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tdelete_line",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tdelete_line = delete_line - 1\n\ttemp.close()\n\tshutil.move(\"temp\", \"src/env/ged_env.hpp\")\ndef append_cmake_lists(identifier):\n    append = \"\"\n    append = append + \"\\n\"\n    append = append + \"add_library(\" + identifier.lower() + \"gedlib SHARED env/ged_env.\" + identifier.lower() + \".cpp)\\n\"\n    append = append + \"set_target_properties(\" + identifier.lower() + \"gedlib PROPERTIES SUFFIX \\\".so\\\")\\n\"\n    append = append + \"target_link_libraries(\" + identifier.lower() + \"gedlib nomad doublefann svm)\\n\"\n    append = append + \"if(APPLE)\\n\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = \"mkdir -p lib; \"\n\tcommands = commands + \"mkdir -p tests/tkde2019/bin; mkdir -p tests/tkde2019/output; \"\n\tcommands = commands + \"mkdir -p tests/vldbj2019/bin; mkdir -p tests/vldbj2019/ini; mkdir -p tests/vldbj2019/results; \"\n\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"\n\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = commands + \"mkdir -p tests/tkde2019/bin; mkdir -p tests/tkde2019/output; \"\n\tcommands = commands + \"mkdir -p tests/vldbj2019/bin; mkdir -p tests/vldbj2019/ini; mkdir -p tests/vldbj2019/results; \"\n\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"\n\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = commands + \"mkdir -p tests/vldbj2019/bin; mkdir -p tests/vldbj2019/ini; mkdir -p tests/vldbj2019/results; \"\n\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"\n\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:\n\t\tprint(\"\\n***** Install external libraries. *****\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = commands + \"mkdir -p median/bin; mkdir -p median/output; mkdir -p median/data; mkdir -p median/data/Letter; mkdir -p median/data/Mutagenicity; \"\n\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:\n\t\tprint(\"\\n***** Install external libraries. *****\")\n\t\tcommands = \"cd ext/fann.2.2.0; mkdir -p build; cd build; rm -rf *; cmake -DCMAKE_INSTALL_PREFIX=.. ..; make install; cd ..; rm -rf build\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = commands + \"mkdir -p tests/sspr2018/bin; mkdir -p tests/sspr2018/output; \"\n\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:\n\t\tprint(\"\\n***** Install external libraries. *****\")\n\t\tcommands = \"cd ext/fann.2.2.0; mkdir -p build; cd build; rm -rf *; cmake -DCMAKE_INSTALL_PREFIX=.. ..; make install; cd ..; rm -rf build\"\n\t\tcall(commands, shell=True) ",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = commands + \"mkdir -p tests/unit_tests/bin; mkdir -p tests/unit_tests/output\"\n\tcall(commands, shell=True)\ndef build_external_libraries():\n\tif os.path.isfile(\"ext/.INSTALLED\"):\n\t\tprint(\"\\n***** External libraries already installed. *****\")\n\telse:\n\t\tprint(\"\\n***** Install external libraries. *****\")\n\t\tcommands = \"cd ext/fann.2.2.0; mkdir -p build; cd build; rm -rf *; cmake -DCMAKE_INSTALL_PREFIX=.. ..; make install; cd ..; rm -rf build\"\n\t\tcall(commands, shell=True) \n\t\tcommands = \"cd ext/nomad.3.8.1; mkdir -p lib; mkdir -p bin; cd src; make clean; make all; make clean; rm -rf ../bin\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd ext/fann.2.2.0; mkdir -p build; cd build; rm -rf *; cmake -DCMAKE_INSTALL_PREFIX=.. ..; make install; cd ..; rm -rf build\"\n\t\tcall(commands, shell=True) \n\t\tcommands = \"cd ext/nomad.3.8.1; mkdir -p lib; mkdir -p bin; cd src; make clean; make all; make clean; rm -rf ../bin\"\n\t\tcall(commands, shell=True)\n\t\tcommands = \"cd ext/libsvm.3.22; make lib; rm -f svm.o\"\n\t\tcall(commands, shell=True)\n\t\tf = open(\"ext/.INSTALLED\", \"w\")\n\t\tf.close()\ndef determine_gurobi_dylib(gurobi_root):\n\tif not os.path.isdir(gurobi_root):",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd ext/nomad.3.8.1; mkdir -p lib; mkdir -p bin; cd src; make clean; make all; make clean; rm -rf ../bin\"\n\t\tcall(commands, shell=True)\n\t\tcommands = \"cd ext/libsvm.3.22; make lib; rm -f svm.o\"\n\t\tcall(commands, shell=True)\n\t\tf = open(\"ext/.INSTALLED\", \"w\")\n\t\tf.close()\ndef determine_gurobi_dylib(gurobi_root):\n\tif not os.path.isdir(gurobi_root):\n\t\traise Exception(\"Invalid argument \\\"\" + gurobi_root + \"\\\" for option gurobi: not a directory. Usage: python install.py [--gurobi <path-to-root-directory-of-Gurobi>] [...]\")\n\treturn \"gurobi\" + gurobi_root[gurobi_root.index(\"gurobi\") + 6 : gurobi_root.index(\"gurobi\") + 8]",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd ext/libsvm.3.22; make lib; rm -f svm.o\"\n\t\tcall(commands, shell=True)\n\t\tf = open(\"ext/.INSTALLED\", \"w\")\n\t\tf.close()\ndef determine_gurobi_dylib(gurobi_root):\n\tif not os.path.isdir(gurobi_root):\n\t\traise Exception(\"Invalid argument \\\"\" + gurobi_root + \"\\\" for option gurobi: not a directory. Usage: python install.py [--gurobi <path-to-root-directory-of-Gurobi>] [...]\")\n\treturn \"gurobi\" + gurobi_root[gurobi_root.index(\"gurobi\") + 6 : gurobi_root.index(\"gurobi\") + 8]\ndef determine_gurobi_statlib(gurobi_root):\n\tstatlib = \"gurobi_c++\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tf",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tf = open(\"ext/.INSTALLED\", \"w\")\n\t\tf.close()\ndef determine_gurobi_dylib(gurobi_root):\n\tif not os.path.isdir(gurobi_root):\n\t\traise Exception(\"Invalid argument \\\"\" + gurobi_root + \"\\\" for option gurobi: not a directory. Usage: python install.py [--gurobi <path-to-root-directory-of-Gurobi>] [...]\")\n\treturn \"gurobi\" + gurobi_root[gurobi_root.index(\"gurobi\") + 6 : gurobi_root.index(\"gurobi\") + 8]\ndef determine_gurobi_statlib(gurobi_root):\n\tstatlib = \"gurobi_c++\"\n\tif platform.system() == \"Linux\":\n\t\tinfo = {item.split(\":\\t\")[0] : item.split(\":\\t\")[1] for item in subprocess.check_output(\"lsb_release -a\", shell=True).decode(\"utf-8\").split(\"\\n\")[:-1]}",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tstatlib",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tstatlib = \"gurobi_c++\"\n\tif platform.system() == \"Linux\":\n\t\tinfo = {item.split(\":\\t\")[0] : item.split(\":\\t\")[1] for item in subprocess.check_output(\"lsb_release -a\", shell=True).decode(\"utf-8\").split(\"\\n\")[:-1]}\n\t\tif info[\"Distributor ID\"] == \"Ubuntu\" and (info[\"Release\"] == \"16.04\" or info[\"Release\"] == \"18.04\"):\n\t\t\tstatlib = \"gurobi_g++5.2\"\n\treturn statlib\t\ndef build_gedlib(args):\n\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":\n\t\tidentifier, node_id_type, node_label_type, edge_label_type = parse_custom_types(args.lib)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tinfo",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tinfo = {item.split(\":\\t\")[0] : item.split(\":\\t\")[1] for item in subprocess.check_output(\"lsb_release -a\", shell=True).decode(\"utf-8\").split(\"\\n\")[:-1]}\n\t\tif info[\"Distributor ID\"] == \"Ubuntu\" and (info[\"Release\"] == \"16.04\" or info[\"Release\"] == \"18.04\"):\n\t\t\tstatlib = \"gurobi_g++5.2\"\n\treturn statlib\t\ndef build_gedlib(args):\n\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":\n\t\tidentifier, node_id_type, node_label_type, edge_label_type = parse_custom_types(args.lib)\n\t\tif identifier.lower() == \"gxl\":\n\t\t\traise Exception(\"Invalid argument \\\"\" + args.lib + \"\\\" for option lib. Usage: python install.py [--lib gxl|<indentifier-different-from-'gxl'>,<node-ID-type>,<node-label-type>,<edge-label-type>] [...]\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tstatlib",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tstatlib = \"gurobi_g++5.2\"\n\treturn statlib\t\ndef build_gedlib(args):\n\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":\n\t\tidentifier, node_id_type, node_label_type, edge_label_type = parse_custom_types(args.lib)\n\t\tif identifier.lower() == \"gxl\":\n\t\t\traise Exception(\"Invalid argument \\\"\" + args.lib + \"\\\" for option lib. Usage: python install.py [--lib gxl|<indentifier-different-from-'gxl'>,<node-ID-type>,<node-label-type>,<edge-label-type>] [...]\")\n\t\tprint(\"\\n***** Modify sources for building user-defined shared library. *****\")\n\t\tcreate_template_instantiation(identifier, node_id_type, node_label_type, edge_label_type)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tidentifier",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tidentifier = \"gxl\"\n\tif args.lib and args.lib != \"gxl\":\n\t\tidentifier, node_id_type, node_label_type, edge_label_type = parse_custom_types(args.lib)\n\t\tif identifier.lower() == \"gxl\":\n\t\t\traise Exception(\"Invalid argument \\\"\" + args.lib + \"\\\" for option lib. Usage: python install.py [--lib gxl|<indentifier-different-from-'gxl'>,<node-ID-type>,<node-label-type>,<edge-label-type>] [...]\")\n\t\tprint(\"\\n***** Modify sources for building user-defined shared library. *****\")\n\t\tcreate_template_instantiation(identifier, node_id_type, node_label_type, edge_label_type)\n\t\tappend_ged_env_hpp(identifier, node_id_type, node_label_type, edge_label_type)\n\t\tappend_cmake_lists(identifier)\n\tif args.clean:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"rm -rf build\"\n\t\tcall(commands, shell=True)\n\tprint(\"\\n***** Goto build directory. *****\")\n\tcommands = \"mkdir -p build\"\n\tcall(commands, shell=True)\n\tif (not os.path.isfile(\"build/Makefile\")):\n\t\tprint(\"\\n***** Run CMake. *****\")\n\t\tcommands = \"cd build; rm -rf *; cmake .. -DCMAKE_BUILD_TYPE=\"\n\t\tif args.debug:\n\t\t\tcommands = commands + \"Debug\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\tcommands = \"mkdir -p build\"\n\tcall(commands, shell=True)\n\tif (not os.path.isfile(\"build/Makefile\")):\n\t\tprint(\"\\n***** Run CMake. *****\")\n\t\tcommands = \"cd build; rm -rf *; cmake .. -DCMAKE_BUILD_TYPE=\"\n\t\tif args.debug:\n\t\t\tcommands = commands + \"Debug\"\n\t\telse:\n\t\t\tcommands = commands + \"Release\"\n\t\tif args.gurobi:",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd build; rm -rf *; cmake .. -DCMAKE_BUILD_TYPE=\"\n\t\tif args.debug:\n\t\t\tcommands = commands + \"Debug\"\n\t\telse:\n\t\t\tcommands = commands + \"Release\"\n\t\tif args.gurobi:\n\t\t\tcommands = commands + \" -DGUROBI_ROOT=\" + args.gurobi + \" -DGUROBI_DYLIB=\" + determine_gurobi_dylib(args.gurobi) + \" -DGUROBI_STATLIB=\" + determine_gurobi_statlib(args.gurobi)\n\t\tif platform.system() == \"Darwin\":\n\t\t\tcommands = commands + \" -DOMP_HOME=\" + check_output(\"brew --prefix\", shell=True).decode(\"utf-8\")\n\t\tcall(commands, shell=True)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = commands + \"Debug\"\n\t\telse:\n\t\t\tcommands = commands + \"Release\"\n\t\tif args.gurobi:\n\t\t\tcommands = commands + \" -DGUROBI_ROOT=\" + args.gurobi + \" -DGUROBI_DYLIB=\" + determine_gurobi_dylib(args.gurobi) + \" -DGUROBI_STATLIB=\" + determine_gurobi_statlib(args.gurobi)\n\t\tif platform.system() == \"Darwin\":\n\t\t\tcommands = commands + \" -DOMP_HOME=\" + check_output(\"brew --prefix\", shell=True).decode(\"utf-8\")\n\t\tcall(commands, shell=True)\n\tif args.doc:\n\t\tprint(\"\\n***** Generate documentation. *****\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = commands + \"Release\"\n\t\tif args.gurobi:\n\t\t\tcommands = commands + \" -DGUROBI_ROOT=\" + args.gurobi + \" -DGUROBI_DYLIB=\" + determine_gurobi_dylib(args.gurobi) + \" -DGUROBI_STATLIB=\" + determine_gurobi_statlib(args.gurobi)\n\t\tif platform.system() == \"Darwin\":\n\t\t\tcommands = commands + \" -DOMP_HOME=\" + check_output(\"brew --prefix\", shell=True).decode(\"utf-8\")\n\t\tcall(commands, shell=True)\n\tif args.doc:\n\t\tprint(\"\\n***** Generate documentation. *****\")\n\t\tcommands = \"cd build; make doc\"\n\t\tcall(commands, shell=True)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = commands + \" -DGUROBI_ROOT=\" + args.gurobi + \" -DGUROBI_DYLIB=\" + determine_gurobi_dylib(args.gurobi) + \" -DGUROBI_STATLIB=\" + determine_gurobi_statlib(args.gurobi)\n\t\tif platform.system() == \"Darwin\":\n\t\t\tcommands = commands + \" -DOMP_HOME=\" + check_output(\"brew --prefix\", shell=True).decode(\"utf-8\")\n\t\tcall(commands, shell=True)\n\tif args.doc:\n\t\tprint(\"\\n***** Generate documentation. *****\")\n\t\tcommands = \"cd build; make doc\"\n\t\tcall(commands, shell=True)\n\tif args.lib:\n\t\tprint(\"\\n***** Build shared library. *****\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = commands + \" -DOMP_HOME=\" + check_output(\"brew --prefix\", shell=True).decode(\"utf-8\")\n\t\tcall(commands, shell=True)\n\tif args.doc:\n\t\tprint(\"\\n***** Generate documentation. *****\")\n\t\tcommands = \"cd build; make doc\"\n\t\tcall(commands, shell=True)\n\tif args.lib:\n\t\tprint(\"\\n***** Build shared library. *****\")\n\t\tcommands = \"cd build; make \" + identifier.lower() + \"gedlib\"\n\t\tcall(commands, shell=True)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd build; make doc\"\n\t\tcall(commands, shell=True)\n\tif args.lib:\n\t\tprint(\"\\n***** Build shared library. *****\")\n\t\tcommands = \"cd build; make \" + identifier.lower() + \"gedlib\"\n\t\tcall(commands, shell=True)\n\tif args.tests:\n\t\tprint(\"\\n***** Build test executables. *****\")\n\t\tif args.tests == \"all\":\n\t\t\tcommands = \"cd build; make tests\"",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\tcommands = \"cd build; make \" + identifier.lower() + \"gedlib\"\n\t\tcall(commands, shell=True)\n\tif args.tests:\n\t\tprint(\"\\n***** Build test executables. *****\")\n\t\tif args.tests == \"all\":\n\t\t\tcommands = \"cd build; make tests\"\n\t\t\tcall(commands, shell=True)\n\t\telse:\n\t\t\tcommands = \"cd build; make \" + args.tests\n\t\t\tcall(commands, shell=True)",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = \"cd build; make tests\"\n\t\t\tcall(commands, shell=True)\n\t\telse:\n\t\t\tcommands = \"cd build; make \" + args.tests\n\t\t\tcall(commands, shell=True)\nprint(\"**************************************************\")\nprint(\"                    GEDLIB 1.0                    \")\nprint(\"                Installation Script               \")\nprint(\"**************************************************\")\nparser = argparse.ArgumentParser(description=\"Installs GEDLIB and its dependencies unless they have already been installed.\", epilog=\"If called without arguments, only the dependencies are installed.\")",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommands",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "\t\t\tcommands = \"cd build; make \" + args.tests\n\t\t\tcall(commands, shell=True)\nprint(\"**************************************************\")\nprint(\"                    GEDLIB 1.0                    \")\nprint(\"                Installation Script               \")\nprint(\"**************************************************\")\nparser = argparse.ArgumentParser(description=\"Installs GEDLIB and its dependencies unless they have already been installed.\", epilog=\"If called without arguments, only the dependencies are installed.\")\nparser.add_argument(\"--doc\", help=\"build documentation\", action=\"store_true\")\nparser.add_argument(\"--lib\", help=\"build shared library\", metavar=\"gxl|<indentifier>,<UserNodeID>,<UserNodeLabel>,<UserEdgeLabel>\")\nparser.add_argument(\"--tests\", help=\"build test executables\", metavar=\"all|unit_tests|ged_env_tests|lsap_solver_tests|pr2018|sspr2018|vldbj2019|vldbj_train_ml|vldbj_test_lsape_based_methods|vldbj_test_lp_based_methods|vldbj_test_ls_based_methods|vldbj_test_misc_methods|median|cluster|bst\", choices=[\"all\", \"unit_tests\", \"ged_env_tests\", \"lsap_solver_tests\", \"pr2018\", \"sspr2018\", \"vldbj2019\", \"vldbj_train_ml\", \"vldbj_test_lsape_based_methods\", \"vldbj_test_lp_based_methods\", \"vldbj_test_ls_based_methods\", \"vldbj_test_misc_methods\", \"median\", \"cluster\", \"bst\"])",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Installs GEDLIB and its dependencies unless they have already been installed.\", epilog=\"If called without arguments, only the dependencies are installed.\")\nparser.add_argument(\"--doc\", help=\"build documentation\", action=\"store_true\")\nparser.add_argument(\"--lib\", help=\"build shared library\", metavar=\"gxl|<indentifier>,<UserNodeID>,<UserNodeLabel>,<UserEdgeLabel>\")\nparser.add_argument(\"--tests\", help=\"build test executables\", metavar=\"all|unit_tests|ged_env_tests|lsap_solver_tests|pr2018|sspr2018|vldbj2019|vldbj_train_ml|vldbj_test_lsape_based_methods|vldbj_test_lp_based_methods|vldbj_test_ls_based_methods|vldbj_test_misc_methods|median|cluster|bst\", choices=[\"all\", \"unit_tests\", \"ged_env_tests\", \"lsap_solver_tests\", \"pr2018\", \"sspr2018\", \"vldbj2019\", \"vldbj_train_ml\", \"vldbj_test_lsape_based_methods\", \"vldbj_test_lp_based_methods\", \"vldbj_test_ls_based_methods\", \"vldbj_test_misc_methods\", \"median\", \"cluster\", \"bst\"])\nparser.add_argument(\"--gurobi\", metavar=\"<GUROBI_ROOT>\", help=\"specify path to directory containing Gurobi\")\nparser.add_argument(\"--debug\", help=\"build in debug mode\", action=\"store_true\")\nparser.add_argument(\"--clean\", help=\"clean build directory and update makefile before build\", action=\"store_true\")\nargs = parser.parse_args()\nbuild_external_libraries()\ncreate_directories()",
        "detail": "install",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "install",
        "description": "install",
        "peekOfCode": "args = parser.parse_args()\nbuild_external_libraries()\ncreate_directories()\nif args.lib or args.tests or args.doc:\n\tbuild_gedlib(args)\nprint(\"\\n***** Successfully installed GEDLIB. *****\")",
        "detail": "install",
        "documentation": {}
    }
]